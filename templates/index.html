<!DOCTYPE html>
<html>
<head>
    <title>MARBEFES BBT Database</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-geometryutil@0.10.1/src/leaflet.geometryutil.js"></script>

    <!-- PyDeck/Deck.gl Dependencies -->
    <script src="https://unpkg.com/deck.gl@^8.9.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/layers@^8.9.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/geo-layers@^8.9.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/aggregation-layers@^8.9.0/dist.min.js"></script>
    <style>
        :root {
            /* Ocean Blue Theme (default) */
            --primary-color: #20B2AA;
            --secondary-color: #008B8B;
            --accent-color: #40E0D0;
            --sidebar-bg: linear-gradient(135deg, #f8f9ff 0%, #e3f2fd 50%, #f0f8ff 100%);
            --card-bg: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(248,249,250,0.95) 100%);
            --text-color: #2F4F4F;
            --border-color: rgba(32, 178, 170, 0.2);
            --shadow-color: rgba(32, 178, 170, 0.15);
        }

        [data-theme="forest"] {
            --primary-color: #228B22;
            --secondary-color: #006400;
            --accent-color: #32CD32;
            --sidebar-bg: linear-gradient(135deg, #f0fff0 0%, #e6ffe6 50%, #f5fff5 100%);
            --card-bg: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(240,255,240,0.95) 100%);
            --text-color: #1F4F1F;
            --border-color: rgba(34, 139, 34, 0.2);
            --shadow-color: rgba(34, 139, 34, 0.15);
        }

        [data-theme="sunset"] {
            --primary-color: #FF8C00;
            --secondary-color: #FF6347;
            --accent-color: #FFD700;
            --sidebar-bg: linear-gradient(135deg, #fff8f0 0%, #ffe6cc 50%, #fff4e6 100%);
            --card-bg: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,248,240,0.95) 100%);
            --text-color: #8B4513;
            --border-color: rgba(255, 140, 0, 0.2);
            --shadow-color: rgba(255, 140, 0, 0.15);
        }

        [data-theme="midnight"] {
            --primary-color: #6A5ACD;
            --secondary-color: #483D8B;
            --accent-color: #9370DB;
            --sidebar-bg: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --card-bg: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            --text-color: #E6E6FA;
            --border-color: rgba(106, 90, 205, 0.3);
            --shadow-color: rgba(106, 90, 205, 0.2);
        }

        [data-theme="arctic"] {
            --primary-color: #4682B4;
            --secondary-color: #5F9EA0;
            --accent-color: #87CEEB;
            --sidebar-bg: linear-gradient(135deg, #ffffff 0%, #f8f8ff 50%, #f0f8ff 100%);
            --card-bg: linear-gradient(135deg, rgba(255,255,255,0.95) 0%, rgba(248,248,255,0.98) 100%);
            --text-color: #2F4F4F;
            --border-color: rgba(70, 130, 180, 0.2);
            --shadow-color: rgba(70, 130, 180, 0.1);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f0f0;
            color: var(--text-color);
        }
        #container {
            display: flex;
            height: 100vh;
        }
        #sidebar {
            width: 320px;
            background: var(--sidebar-bg);
            padding: 20px;
            box-shadow: 2px 0 15px var(--shadow-color);
            overflow-y: auto;
            z-index: 1000;
            border-right: 1px solid var(--border-color);
        }
        #map {
            flex: 1;
            position: relative;
        }
        h1 {
            color: #2F4F4F;
            font-size: 24px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .logo {
            height: 40px;
            width: auto;
            margin-right: 12px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .help-icon {
            font-size: 18px;
            color: #20B2AA;
            cursor: help;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
            white-space: pre-line;
        }
        .help-icon:hover {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.5);
            transform: scale(1.1);
        }
        .subtitle {
            color: #7f8c8d;
            font-size: 12px;
            margin-bottom: 15px;
        }

        .project-info {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 3px 12px var(--shadow-color);
        }

        .project-links {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
        }

        .project-links a {
            color: #20B2AA;
            text-decoration: none;
            padding: 4px 8px;
            background: white;
            border-radius: 4px;
            font-size: 11px;
            border: 1px solid #dee2e6;
            transition: all 0.2s ease;
        }

        .project-links a:hover {
            background: #20B2AA;
            color: white;
            transform: translateY(-1px);
        }

        .grant-info {
            text-align: center;
            color: #6c757d;
            font-style: italic;
        }

        .bbt-nav-section {
            margin-bottom: 20px;
        }

        .bbt-nav-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
            align-items: stretch;
        }

        .bbt-button-row {
            display: flex;
            gap: 8px;
            align-items: center;
            width: 100%;
        }

        .bbt-nav-btn {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: var(--button-text-color);
            border: none;
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            box-shadow: 0 2px 4px var(--shadow-color);
            text-transform: capitalize;
            flex: 1;
            text-align: left;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bbt-nav-btn:hover {
            transform: translateX(3px);
            box-shadow: 0 4px 8px var(--shadow-color);
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--primary-color) 100%);
        }

        .bbt-nav-btn:active {
            transform: translateX(0px);
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .bbt-nav-btn.active {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--primary-color) 100%);
            box-shadow: 0 2px 6px var(--shadow-color);
        }

        .bbt-data-btn {
            background: linear-gradient(135deg, #FF8C00 0%, #FF6347 100%);
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(255, 140, 0, 0.3);
            white-space: nowrap;
            flex-shrink: 0;
        }

        .bbt-data-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(255, 140, 0, 0.5);
            background: linear-gradient(135deg, #FFD700 0%, #FF8C00 100%);
        }

        .bbt-data-btn:active {
            transform: scale(0.98);
        }

        /* BBT Data Popup Modal */
        .bbt-popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 10000;
            animation: fadeIn 0.3s ease;
        }

        .bbt-popup-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bbt-popup {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease;
        }

        .bbt-popup-header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            padding: 20px;
            border-radius: 16px 16px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bbt-popup-title {
            font-size: 20px;
            font-weight: 600;
            margin: 0;
        }

        .bbt-popup-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 24px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bbt-popup-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .bbt-popup-content {
            padding: 20px;
        }

        .bbt-data-field {
            margin-bottom: 16px;
        }

        .bbt-data-field label {
            display: block;
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 6px;
            font-size: 13px;
        }

        .bbt-data-field input,
        .bbt-data-field textarea,
        .bbt-data-field select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            box-sizing: border-box;
        }

        .bbt-data-field input:focus,
        .bbt-data-field textarea:focus,
        .bbt-data-field select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .bbt-data-field textarea {
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
        }

        .bbt-popup-actions {
            display: flex;
            gap: 12px;
            padding: 20px;
            border-top: 1px solid #e0e0e0;
            justify-content: flex-end;
        }

        .bbt-popup-btn {
            padding: 10px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .bbt-popup-btn-save {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
        }

        .bbt-popup-btn-save:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        .bbt-popup-btn-cancel {
            background: #f5f5f5;
            color: #666;
        }

        .bbt-popup-btn-cancel:hover {
            background: #e0e0e0;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h3 {
            color: var(--text-color);
            font-size: 16px;
            margin-top: 20px;
            margin-bottom: 10px;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 5px;
        }

        #info {
            background: linear-gradient(135deg, #20B2AA 0%, #008B8B 100%);
            color: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 13px;
            line-height: 1.6;
        }
        .controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #495057;
            font-weight: 600;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--input-bg);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }
        .value-display {
            text-align: center;
            font-size: 14px;
            color: var(--primary-color);
            font-weight: bold;
            margin-top: 5px;
        }
        .legend-container {
            margin-top: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .legend-container h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #495057;
        }
        #legend-image {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        .status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 12px;
            color: #20B2AA;
            font-weight: 600;
        }
        .loading {
            color: #FF8C00;
        }
        .error {
            color: #CD5C5C;
        }

        /* Custom popup styling */
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .leaflet-popup-content {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .leaflet-popup-content h1, .leaflet-popup-content h2, .leaflet-popup-content h3 {
            color: #2F4F4F;
            margin-top: 0;
        }
        .leaflet-popup-content table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .leaflet-popup-content th, .leaflet-popup-content td {
            padding: 4px 8px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        .leaflet-popup-content th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        /* Hover tooltip styles */
        .vector-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            white-space: nowrap;
            transform: translateX(-50%);
        }

        .vector-tooltip .tooltip-title {
            font-weight: bold;
            margin-bottom: 4px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 4px;
        }

        .vector-tooltip .tooltip-area {
            color: #90EE90;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1>
                <img src="/logo/marbefes_02.png" alt="MARBEFES Logo" class="logo">
                MARBEFES BBT Database
                <span class="help-icon" title="MARBEFES BBT Database&#10;&#10;‚Ä¢ Browse Broad Belt Transect (BBT) vector data layers&#10;‚Ä¢ View EMODnet seabed habitat data overlays&#10;‚Ä¢ Access HELCOM Baltic Sea environmental pressure data&#10;‚Ä¢ Use your mouse to pan and zoom the map&#10;‚Ä¢ Click on features for detailed information&#10;‚Ä¢ Hover over BBT polygons for area calculations">‚ìò</span>
            </h1>
            <div class="subtitle">Marine Biodiversity and Ecosystem Functioning leading to Ecosystem Services</div>

            <h3>BBT Quick Navigation</h3>
            <div class="bbt-nav-section">
                <div class="bbt-nav-buttons" id="bbt-nav-buttons">
                    <!-- Vertical left-aligned BBT buttons with data buttons -->
                    <div class="bbt-button-row">
                        <button class="bbt-nav-btn" onclick="zoomToBBTArea('Archipelago')" title="üó∫Ô∏è Zoom to Archipelago BBT area">Archipelago</button>
                        <button class="bbt-data-btn" onclick="openBBTDataPopup('Archipelago')" title="üìä View/Edit BBT Data">üìä</button>
                    </div>
                    <div class="bbt-button-row">
                        <button class="bbt-nav-btn" onclick="zoomToBBTArea('Balearic')" title="üó∫Ô∏è Zoom to Balearic BBT area">Balearic</button>
                        <button class="bbt-data-btn" onclick="openBBTDataPopup('Balearic')" title="üìä View/Edit BBT Data">üìä</button>
                    </div>
                    <div class="bbt-button-row">
                        <button class="bbt-nav-btn" onclick="zoomToBBTArea('Bay of Gdansk')" title="üó∫Ô∏è Zoom to Bay of Gdansk BBT area">Bay of Gdansk</button>
                        <button class="bbt-data-btn" onclick="openBBTDataPopup('Bay of Gdansk')" title="üìä View/Edit BBT Data">üìä</button>
                    </div>
                    <div class="bbt-button-row">
                        <button class="bbt-nav-btn" onclick="zoomToBBTArea('Gulf of Biscay')" title="üó∫Ô∏è Zoom to Gulf of Biscay BBT area">Gulf of Biscay</button>
                        <button class="bbt-data-btn" onclick="openBBTDataPopup('Gulf of Biscay')" title="üìä View/Edit BBT Data">üìä</button>
                    </div>
                    <div class="bbt-button-row">
                        <button class="bbt-nav-btn" onclick="zoomToBBTArea('Heraklion')" title="üó∫Ô∏è Zoom to Heraklion BBT area">Heraklion</button>
                        <button class="bbt-data-btn" onclick="openBBTDataPopup('Heraklion')" title="üìä View/Edit BBT Data">üìä</button>
                    </div>
                    <div class="bbt-button-row">
                        <button class="bbt-nav-btn" onclick="zoomToBBTArea('Hornsund')" title="üó∫Ô∏è Zoom to Hornsund BBT area">Hornsund</button>
                        <button class="bbt-data-btn" onclick="openBBTDataPopup('Hornsund')" title="üìä View/Edit BBT Data">üìä</button>
                    </div>
                    <div class="bbt-button-row">
                        <button class="bbt-nav-btn" onclick="zoomToBBTArea('Irish Sea')" title="üó∫Ô∏è Zoom to Irish Sea BBT area">Irish Sea</button>
                        <button class="bbt-data-btn" onclick="openBBTDataPopup('Irish Sea')" title="üìä View/Edit BBT Data">üìä</button>
                    </div>
                    <div class="bbt-button-row">
                        <button class="bbt-nav-btn" onclick="zoomToBBTArea('Kongsfjord')" title="üó∫Ô∏è Zoom to Kongsfjord BBT area">Kongsfjord</button>
                        <button class="bbt-data-btn" onclick="openBBTDataPopup('Kongsfjord')" title="üìä View/Edit BBT Data">üìä</button>
                    </div>
                    <div class="bbt-button-row">
                        <button class="bbt-nav-btn" onclick="zoomToBBTArea('Lithuanian coast')" title="üó∫Ô∏è Zoom to Lithuanian coast BBT area">Lithuanian coast</button>
                        <button class="bbt-data-btn" onclick="openBBTDataPopup('Lithuanian coast')" title="üìä View/Edit BBT Data">üìä</button>
                    </div>
                    <div class="bbt-button-row">
                        <button class="bbt-nav-btn" onclick="zoomToBBTArea('North Sea')" title="üó∫Ô∏è Zoom to North Sea BBT area">North Sea</button>
                        <button class="bbt-data-btn" onclick="openBBTDataPopup('North Sea')" title="üìä View/Edit BBT Data">üìä</button>
                    </div>
                    <div class="bbt-button-row">
                        <button class="bbt-nav-btn" onclick="zoomToBBTArea('Sardinia')" title="üó∫Ô∏è Zoom to Sardinia BBT area">Sardinia</button>
                        <button class="bbt-data-btn" onclick="openBBTDataPopup('Sardinia')" title="üìä View/Edit BBT Data">üìä</button>
                    </div>
                    <div class="loading-indicator" id="bbt-loading" style="color: #20B2AA; font-size: 10px; padding: 4px; text-align: center; margin-top: 8px; display: none;">
                        üîÑ Loading enhanced features...
                    </div>
                </div>
            </div>

            <h3>Available Layers</h3>

            <!-- Collapsible EMODnet Overlay Section -->
            <div class="control-group">
                <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; margin-bottom: 8px;" onclick="toggleEmodnetPanel()">
                    <label for="layer-select" style="margin: 0; cursor: pointer; flex: 1;">Select EMODnet Overlay</label>
                    <span id="emodnet-status-tooltip" style="font-size: 11px; color: #666; margin: 0 8px; max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="">No layer</span>
                    <span id="emodnet-toggle-icon" style="font-size: 16px; color: #20B2AA;">‚ñº</span>
                </div>
                <div id="emodnet-panel" style="display: block; margin-top: 0px;">
                    <select id="layer-select" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                    </select>
                </div>
            </div>

            <!-- Collapsible HELCOM Overlay Section -->
            <div class="control-group">
                <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; margin-bottom: 8px;" onclick="toggleHelcomPanel()">
                    <label for="helcom-select" style="margin: 0; cursor: pointer; flex: 1;">HELCOM Baltic Sea Overlay</label>
                    <span id="helcom-status-tooltip" style="font-size: 11px; color: #666; margin: 0 8px; max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="">No overlay</span>
                    <span id="helcom-toggle-icon" style="font-size: 16px; color: #20B2AA;">‚ñ∂</span>
                </div>
                <div id="helcom-panel" style="display: none; margin-top: 0px;">
                    <select id="helcom-select" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                    </select>
                </div>
            </div>

            <!-- Collapsible Advanced Controls Section -->
            <div class="control-group">
                <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; margin-bottom: 8px; margin-top: 15px;" onclick="toggleAdvancedPanel()">
                    <h3 style="margin: 0; cursor: pointer; flex: 1; font-size: 14px;">Advanced Controls</h3>
                    <span id="advanced-toggle-icon" style="font-size: 16px; color: #20B2AA;">‚ñ∂</span>
                </div>
            </div>

            <div id="advanced-panel" style="display: none;">
            <div class="controls">
                <div class="control-group">
                    <label for="opacity">Layer Opacity</label>
                    <input type="range" id="opacity" min="0" max="100" value="70">
                    <div class="value-display" id="opacity-value">70%</div>
                </div>

                <div class="control-group">
                    <label for="basemap">Base Map</label>
                    <select id="basemap" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                        <option value="emodnet_bathymetry">EMODnet Bathymetry</option>
                        <option value="osm">OpenStreetMap</option>
                        <option value="satellite" selected>Satellite</option>
                        <option value="ocean">Ocean</option>
                        <option value="light">Light Gray</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="theme">UI Theme</label>
                    <select id="theme" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                        <option value="ocean" selected>Ocean Blue</option>
                        <option value="forest">Forest Green</option>
                        <option value="sunset">Sunset Orange</option>
                        <option value="midnight">Midnight Dark</option>
                        <option value="arctic">Arctic White</option>
                    </select>
                </div>

                <!-- PyDeck 3D Visualization Controls -->
                <div class="control-group">
                    <h4 style="margin: 15px 0 10px 0; color: #2F4F4F; font-size: 14px; border-bottom: 1px solid #20B2AA; padding-bottom: 5px;">3D Visualization</h4>

                    <div style="margin-bottom: 10px;">
                        <label for="enable-3d">
                            <input type="checkbox" id="enable-3d" style="margin-right: 8px;">
                            Enable 3D View
                        </label>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label for="pydeck-layer">PyDeck Layer Type</label>
                        <select id="pydeck-layer" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                            <option value="none">None</option>
                            <option value="hexagon">Hexagon Aggregation</option>
                            <option value="heatmap">Heatmap</option>
                            <option value="grid">Grid Layer</option>
                            <option value="contour">Contour Layer</option>
                            <option value="column">3D Column Chart</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label for="elevation-scale">Elevation Scale</label>
                        <input type="range" id="elevation-scale" min="1" max="10000" value="1000" style="width: 100%;">
                        <div class="value-display" id="elevation-value">1000x</div>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label for="radius-scale">Point Radius</label>
                        <input type="range" id="radius-scale" min="100" max="5000" value="1000" style="width: 100%;">
                        <div class="value-display" id="radius-value">1000m</div>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label for="color-scheme">Color Scheme</label>
                        <select id="color-scheme" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                            <option value="viridis">Viridis (Blue-Green-Yellow)</option>
                            <option value="plasma">Plasma (Purple-Pink-Yellow)</option>
                            <option value="ocean">Ocean (Blue-Cyan-White)</option>
                            <option value="thermal">Thermal (Black-Red-Yellow)</option>
                            <option value="turbo">Turbo (Blue-Cyan-Green-Yellow-Red)</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label for="view-mode">Camera View</label>
                        <select id="view-mode" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                            <option value="2d">2D (Top Down)</option>
                            <option value="3d">3D (Perspective)</option>
                            <option value="bird">Bird's Eye</option>
                            <option value="first-person">First Person</option>
                        </select>
                    </div>
                </div>
            </div>
            </div>

            <!-- Project Info moved to bottom -->
            <div class="project-info" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid rgba(32, 178, 170, 0.3);">
                <div class="project-links">
                    <a href="https://marbefes.eu" target="_blank" title="Visit MARBEFES Project Website">üåê marbefes.eu</a>
                    <a href="https://cordis.europa.eu/project/id/101060937" target="_blank" title="View on CORDIS">üìã CORDIS</a>
                    <a href="https://marbefes.lifewatch.eu" target="_blank" title="MARBEFES Toolbox">üîß Toolbox</a>
                </div>
                <div class="grant-info">
                    <small>Horizon Europe Grant Agreement No. 101060937</small>
                </div>
            </div>

            <div class="legend-container" id="legend-container" style="display: none;">
                <h4>Legend</h4>
                <img id="legend-image" src="" alt="Layer legend">
            </div>
        </div>

        <div id="map"></div>
        <div id="pydeck-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 400;"></div>
        <div class="status" id="status">Ready</div>
    </div>

    <script>
        // Application configuration from Flask
        const API_BASE_URL = '{{ API_BASE_URL }}';
        const WMS_BASE_URL = '{{ WMS_BASE_URL }}';
        const HELCOM_WMS_BASE_URL = '{{ HELCOM_WMS_BASE_URL }}';

        // Initialize map without default zoom control
        var map = L.map('map', { zoomControl: false }).setView([54.0, 10.0], 4);

        // Base maps
        var baseMaps = {
            'emodnet_bathymetry': L.tileLayer('https://tiles.emodnet-bathymetry.eu/latest/mean_atlas_land/web_mercator/{z}/{x}/{y}.png', {
                attribution: '¬© EMODnet Bathymetry | Marine data from European seas',
                minZoom: 0,
                maxZoom: 18
            }),
            'osm': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }),
            'satellite': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri'
            }),
            'ocean': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri'
            }),
            'light': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                attribution: '¬© CartoDB'
            })
        };

        // Add default base map
        var currentBaseMap = baseMaps['satellite'];
        currentBaseMap.addTo(map);

        // Layer data
        const wmsLayers = {{ layers | tojson }};
        const helcomLayers = {{ helcom_layers | tojson }};
        const vectorLayers = {{ vector_layers | tojson }};
        const vectorSupport = {{ vector_support | tojson }};
        const bathymetryStats = {{ bathymetry_stats | tojson }};

        let currentLayer = 'eusm_2023_eunis2019_full'; // Default to EUSeaMap 2023 EUNIS 2019 classification (full resolution)
        let currentLayerType = 'wms';
        let currentOpacity = 0.7;
        let wmsLayer = null;
        let helcomLayer = null;
        let vectorLayerGroup = L.layerGroup().addTo(map);

        // BBT Navigation variables
        let bbtFeatureData = null;
        let currentActiveBBT = null;
        let hoverTooltip = null;

        // BBT Navigation Functions
        async function loadBBTFeatures() {
            console.log('üîÑ Loading BBT features from API...');

            try {
                const apiUrl = `${API_BASE_URL}/vector/layer/${encodeURIComponent('Bbt - Bbt Areas')}`;
                console.log('üì° Fetching from URL:', apiUrl);

                const response = await fetch(apiUrl);
                console.log('üì• API Response status:', response.status);

                if (response.ok) {
                    bbtFeatureData = await response.json();
                    console.log('‚úÖ BBT features loaded successfully:', bbtFeatureData.features ? bbtFeatureData.features.length : 0, 'features');

                    // Only call createBBTNavigationButtons in background loading mode
                    // Buttons are now created statically in HTML
                    console.log('‚ÑπÔ∏è BBT data ready for zoom operations');

                    return bbtFeatureData;
                } else {
                    const errorText = await response.text();

                    // Handle 503 (service unavailable) as a warning, not an error
                    if (response.status === 503) {
                        console.warn('‚ö†Ô∏è Vector service unavailable:', response.status, response.statusText);
                    } else {
                        console.error('‚ùå API Error:', response.status, response.statusText, errorText);
                    }

                    throw new Error(`API Error: ${response.status}`);
                }
            } catch (error) {
                // Only log as error if it's not a 503 (service unavailable)
                if (!error.message.includes('503')) {
                    console.error('‚ùå Network Error loading BBT features:', error);
                }
                throw error;
            }
        }

        function showBBTLoadingError(message) {
            const buttonsContainer = document.getElementById('bbt-nav-buttons');
            if (buttonsContainer) {
                buttonsContainer.innerHTML = `
                    <div style="color: #CD5C5C; font-size: 11px; padding: 8px; text-align: center; border: 1px solid #CD5C5C; border-radius: 4px; background: #f0f8ff;">
                        ‚ö†Ô∏è ${message}
                        <br><small><a href="#" onclick="loadBBTFeatures(); return false;" style="color: #20B2AA;">Try again</a></small>
                    </div>
                `;
            }
        }

        function createBBTNavigationButtons() {
            console.log('‚úÖ Upgrading BBT navigation buttons to interactive mode...');

            if (!bbtFeatureData || !bbtFeatureData.features) {
                console.error('No BBT feature data available');
                showBBTLoadingError('No feature data available');
                return;
            }

            const buttonsContainer = document.getElementById('bbt-nav-buttons');
            if (!buttonsContainer) {
                console.error('BBT buttons container not found');
                return;
            }

            console.log(`Found ${bbtFeatureData.features.length} BBT features to create buttons for`);

            // Show loading indicator
            const loadingElement = document.getElementById('bbt-loading');
            if (loadingElement) {
                loadingElement.style.display = 'block';
            }

            // Get all existing buttons (fallback buttons)
            const existingButtons = buttonsContainer.querySelectorAll('.bbt-nav-btn');
            console.log(`Found ${existingButtons.length} existing buttons to upgrade`);

            // Create feature lookup by name for easy matching
            const featuresByName = {};
            bbtFeatureData.features.forEach(feature => {
                const name = feature.properties.Name;
                if (name) {
                    featuresByName[name] = feature;
                }
            });

            let upgradeCount = 0;

            // Upgrade existing buttons with interactive functionality
            existingButtons.forEach((button, index) => {
                const buttonText = button.textContent.trim();
                const matchingFeature = featuresByName[buttonText];

                if (matchingFeature) {
                    // Replace the onclick with our interactive function
                    button.onclick = () => zoomToBBTFeature(matchingFeature, button);
                    button.title = `üó∫Ô∏è Zoom to ${buttonText} BBT area`;

                    // Add visual indication that it's now interactive
                    button.style.position = 'relative';

                    console.log(`‚úÖ Upgraded button: "${buttonText}"`);
                    upgradeCount++;
                } else {
                    console.warn(`‚ö†Ô∏è No matching feature found for button: "${buttonText}"`);
                }
            });

            // Hide loading indicator
            if (loadingElement) {
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                }, 500);
            }

            console.log(`‚úÖ Successfully upgraded ${upgradeCount} BBT navigation buttons to interactive mode!`);

            // Final verification
            setTimeout(() => {
                const allButtons = buttonsContainer.querySelectorAll('.bbt-nav-btn');
                console.log(`‚úÖ Final verification: ${allButtons.length} interactive buttons ready`);

                // Add subtle animation to show they're now interactive
                allButtons.forEach((btn, idx) => {
                    btn.style.transition = 'all 0.3s ease';
                    setTimeout(() => {
                        btn.style.transform = 'scale(1.05)';
                        setTimeout(() => {
                            btn.style.transform = 'scale(1)';
                        }, 200);
                    }, idx * 50);
                });
            }, 600);
        }

        function zoomToBBTFeature(feature, buttonElement) {
            if (!feature.geometry) return;

            // Calculate bounds for the feature
            let bounds = L.latLngBounds();

            if (feature.geometry.type === 'Polygon') {
                feature.geometry.coordinates[0].forEach(coord => {
                    bounds.extend([coord[1], coord[0]]);
                });
            } else if (feature.geometry.type === 'MultiPolygon') {
                feature.geometry.coordinates.forEach(polygon => {
                    polygon[0].forEach(coord => {
                        bounds.extend([coord[1], coord[0]]);
                    });
                });
            }

            // Zoom to the feature bounds
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [20, 20] });

                // Update active button state
                document.querySelectorAll('.bbt-nav-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                buttonElement.classList.add('active');
                currentActiveBBT = feature.properties.Name;

                // Update status
                document.getElementById('status').textContent = `Zoomed to ${feature.properties.Name}`;

                // Auto-load vector layer if not already loaded
                if (currentLayerType !== 'vector' || !vectorLayerGroup.getLayers().length) {
                    selectVectorLayerAsBase('Bbt - Bbt Areas');
                }
            }
        }

        // Function to calculate area of a feature in square kilometers
        function calculateFeatureArea(feature) {
            if (!feature.geometry) return null;

            try {
                // Use Leaflet's built-in area calculation for polygons
                let area = 0;

                if (feature.geometry.type === 'Polygon') {
                    const coords = feature.geometry.coordinates[0];
                    area = L.GeometryUtil ? L.GeometryUtil.geodesicArea(coords.map(c => L.latLng(c[1], c[0]))) : 0;
                } else if (feature.geometry.type === 'MultiPolygon') {
                    feature.geometry.coordinates.forEach(polygon => {
                        const coords = polygon[0];
                        area += L.GeometryUtil ? L.GeometryUtil.geodesicArea(coords.map(c => L.latLng(c[1], c[0]))) : 0;
                    });
                }

                // Convert from square meters to square kilometers
                return area > 0 ? (area / 1000000).toFixed(2) : null;
            } catch (error) {
                // Fallback: simple bounding box area calculation
                if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                    try {
                        const layer = L.geoJSON(feature);
                        const bounds = layer.getBounds();
                        const area = (bounds.getEast() - bounds.getWest()) * (bounds.getNorth() - bounds.getSouth()) * 12321; // Rough conversion
                        return area > 0 ? area.toFixed(2) : null;
                    } catch (e) {
                        return null;
                    }
                }
                return null;
            }
        }

        // Function to create hover tooltip
        function createTooltip(content, x, y) {
            removeTooltip();

            hoverTooltip = document.createElement('div');
            hoverTooltip.className = 'vector-tooltip';
            hoverTooltip.innerHTML = content;
            hoverTooltip.style.left = x + 'px';
            hoverTooltip.style.top = (y - 10) + 'px';

            document.body.appendChild(hoverTooltip);
        }

        // Function to remove hover tooltip
        function removeTooltip() {
            if (hoverTooltip) {
                document.body.removeChild(hoverTooltip);
                hoverTooltip = null;
            }
        }

        // Function to update tooltip position
        function updateTooltip(x, y) {
            if (hoverTooltip) {
                hoverTooltip.style.left = x + 'px';
                hoverTooltip.style.top = (y - 10) + 'px';
            }
        }

        // Enhanced BBT region information from MARBEFES project
        const bbtRegionInfo = {
            'Archipelago': {
                region: 'Baltic Sea',
                description: 'Marine ecosystem functioning in the Swedish archipelago region',
                habitat: 'Coastal archipelago with complex habitat mosaic',
                research_focus: 'Benthic-pelagic coupling in coastal zones'
            },
            'Balearic': {
                region: 'Mediterranean Sea',
                description: 'Subtropical Mediterranean marine biodiversity hotspot',
                habitat: 'Mediterranean endemic species and Posidonia meadows',
                research_focus: 'Climate change impacts on Mediterranean ecosystems'
            },
            'Bay of Gdansk': {
                region: 'Baltic Sea',
                description: 'Semi-enclosed bay ecosystem with riverine influence',
                habitat: 'Brackish water transitional zone',
                research_focus: 'Land-sea connectivity and nutrient cycling'
            },
            'Gulf of Biscay': {
                region: 'Atlantic Ocean',
                description: 'Continental shelf ecosystem with upwelling dynamics',
                habitat: 'Deep-water Atlantic marine communities',
                research_focus: 'Ocean-shelf biodiversity gradients'
            },
            'Heraklion': {
                region: 'Mediterranean Sea',
                description: 'Eastern Mediterranean oligotrophic ecosystem',
                habitat: 'Deep Mediterranean basinal communities',
                research_focus: 'Deep-sea connectivity and endemic biodiversity'
            },
            'Hornsund': {
                region: 'Arctic Ocean',
                description: 'High Arctic fjord system with glacial influence',
                habitat: 'Arctic marine communities under climate change',
                research_focus: 'Arctic ecosystem resilience and tipping points'
            },
            'Kongsfjord': {
                region: 'Arctic Ocean',
                description: 'Arctic-Atlantic transition zone in Svalbard',
                habitat: 'Arctic-boreal species transition zone',
                research_focus: 'Climate-driven Arctic "atlantification"'
            },
            'Lithuanian coast': {
                region: 'Baltic Sea',
                description: 'Shallow coastal ecosystem with freshwater inputs',
                habitat: 'Sandy coastal waters with estuarine influence',
                research_focus: 'Coastal zone management and eutrophication'
            },
            'North Sea': {
                region: 'North Sea',
                description: 'Productive temperate shelf ecosystem',
                habitat: 'Continental shelf with diverse benthic communities',
                research_focus: 'Anthropogenic impacts and ecosystem services'
            },
            'Irish Sea': {
                region: 'Irish Sea',
                description: 'Semi-enclosed temperate marine ecosystem',
                habitat: 'Coastal and shelf habitats with tidal dynamics',
                research_focus: 'Marine spatial planning and biodiversity conservation'
            },
            'Sardinia': {
                region: 'Mediterranean Sea',
                description: 'Western Mediterranean island ecosystem',
                habitat: 'Mediterranean shelf communities and canyons',
                research_focus: 'Island biogeography and connectivity'
            }
        };

        // Function to generate enhanced tooltip content for BBT features with MARBEFES context
        function generateTooltipContent(feature, layerName) {
            let content = '';

            if (layerName && layerName.toLowerCase().includes('bbt')) {
                // Special handling for BBT layers with MARBEFES context
                const siteName = feature.properties?.Name || feature.properties?.name;
                const siteInfo = siteName ? bbtRegionInfo[siteName] : null;

                content += '<div class="tooltip-title">üåä MARBEFES Broad Belt Transect</div>';

                if (siteName) {
                    content += `<div style="font-weight: 600; color: #FFFFFF; margin: 4px 0;">${siteName}</div>`;
                }

                // Calculate area
                const area = calculateFeatureArea(feature);
                if (area) {
                    content += `<div class="tooltip-area">üìê Area: ${area} km¬≤</div>`;
                }

                // Add MARBEFES project context
                if (siteInfo) {
                    content += `<div style="margin: 8px 0; padding: 6px; background: rgba(32, 178, 170, 0.1); border-radius: 4px;">`;
                    content += `<div style="font-size: 11px; color: #20B2AA; font-weight: 600;">üó∫Ô∏è ${siteInfo.region}</div>`;
                    content += `<div style="font-size: 10px; margin-top: 2px; color: #E2E8F0;">${siteInfo.description}</div>`;
                    content += `<div style="font-size: 10px; margin-top: 3px; color: #CBD5E0;"><strong>Habitat:</strong> ${siteInfo.habitat}</div>`;
                    content += `<div style="font-size: 10px; margin-top: 2px; color: #CBD5E0;"><strong>Research:</strong> ${siteInfo.research_focus}</div>`;
                    content += `</div>`;
                } else {
                    // Generic MARBEFES info if specific site not found
                    content += `<div style="margin: 8px 0; padding: 6px; background: rgba(32, 178, 170, 0.1); border-radius: 4px;">`;
                    content += `<div style="font-size: 10px; color: #E2E8F0;">Part of the MARBEFES project studying marine biodiversity across European seas from river-to-ocean gradients.</div>`;
                    content += `</div>`;
                }




            } else {
                // Generic vector layer tooltip
                content += '<div class="tooltip-title">Vector Feature</div>';
                const area = calculateFeatureArea(feature);
                if (area) {
                    content += `<div class="tooltip-area">Area: ${area} km¬≤</div>`;
                }

                // Show first few properties
                if (feature.properties) {
                    const propEntries = Object.entries(feature.properties).slice(0, 3);
                    propEntries.forEach(([key, value]) => {
                        if (value !== null && value !== undefined && value !== '') {
                            content += `<div>${key}: ${value}</div>`;
                        }
                    });
                }
            }

            return content;
        }

        // Function to zoom to layer extent with scale awareness
        function zoomToLayerExtent(layerName) {
            // Get layer bounds from WMS GetCapabilities
            const capabilitiesUrl = '{{ WMS_BASE_URL }}?service=WMS&version=1.3.0&request=GetCapabilities';

            fetch(capabilitiesUrl)
                .then(response => response.text())
                .then(data => {
                    // Parse XML
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(data, "text/xml");

                    // Find the layer
                    const layers = xmlDoc.getElementsByTagName('Layer');
                    for (let i = 0; i < layers.length; i++) {
                        const nameElement = layers[i].getElementsByTagName('Name')[0];
                        if (nameElement && nameElement.textContent === layerName) {

                            // Extract scale denominators for the layer
                            let minScale = null;
                            let maxScale = null;

                            const minScaleElement = layers[i].getElementsByTagName('MinScaleDenominator')[0];
                            const maxScaleElement = layers[i].getElementsByTagName('MaxScaleDenominator')[0];

                            if (minScaleElement) {
                                minScale = parseFloat(minScaleElement.textContent);
                            }
                            if (maxScaleElement) {
                                maxScale = parseFloat(maxScaleElement.textContent);
                            }

                            // Look for BoundingBox or EX_GeographicBoundingBox
                            let boundingBox = layers[i].getElementsByTagName('EX_GeographicBoundingBox')[0];
                            if (!boundingBox) {
                                boundingBox = layers[i].getElementsByTagName('LatLonBoundingBox')[0];
                            }

                            if (boundingBox) {
                                let west, south, east, north;

                                // Try EX_GeographicBoundingBox format (WMS 1.3.0)
                                const westBound = boundingBox.getElementsByTagName('westBoundLongitude')[0];
                                const southBound = boundingBox.getElementsByTagName('southBoundLatitude')[0];
                                const eastBound = boundingBox.getElementsByTagName('eastBoundLongitude')[0];
                                const northBound = boundingBox.getElementsByTagName('northBoundLatitude')[0];

                                if (westBound && southBound && eastBound && northBound) {
                                    west = parseFloat(westBound.textContent);
                                    south = parseFloat(southBound.textContent);
                                    east = parseFloat(eastBound.textContent);
                                    north = parseFloat(northBound.textContent);
                                } else {
                                    // Try LatLonBoundingBox format (WMS 1.1.1)
                                    west = parseFloat(boundingBox.getAttribute('minx'));
                                    south = parseFloat(boundingBox.getAttribute('miny'));
                                    east = parseFloat(boundingBox.getAttribute('maxx'));
                                    north = parseFloat(boundingBox.getAttribute('maxy'));
                                }

                                if (!isNaN(west) && !isNaN(south) && !isNaN(east) && !isNaN(north)) {
                                    // Calculate appropriate zoom level based on scale constraints
                                    const bounds = [[south, west], [north, east]];

                                    // Calculate zoom level that respects scale constraints
                                    let targetZoom = calculateOptimalZoom(bounds, minScale, maxScale);

                                    if (targetZoom) {
                                        // Use calculated zoom level
                                        const center = [(south + north) / 2, (west + east) / 2];
                                        map.setView(center, targetZoom);
                                    } else {
                                        // Fallback to fitBounds with constraints
                                        const fitOptions = { padding: [20, 20] };

                                        // Apply zoom constraints if available
                                        if (minScale || maxScale) {
                                            if (minScale) fitOptions.maxZoom = scaleToZoom(minScale);
                                            if (maxScale) fitOptions.minZoom = scaleToZoom(maxScale);
                                        }

                                        map.fitBounds(bounds, fitOptions);
                                    }
                                    return;
                                }
                            }
                            break;
                        }
                    }

                    // Fallback to European waters if no bounds found
                    map.setView([54.0, 10.0], 4);
                })
                .catch(error => {
                    console.log('Could not get layer extent:', error);
                    // Fallback to European waters
                    map.setView([54.0, 10.0], 4);
                });
        }

        // Helper function to convert scale denominator to approximate zoom level
        function scaleToZoom(scale) {
            // Approximate conversion: scale = 591659030.4 / (2^zoom)
            // This is based on Web Mercator projection at equator
            const baseScale = 591659030.4;
            const zoom = Math.log2(baseScale / scale);
            return Math.max(0, Math.min(18, Math.round(zoom)));
        }

        // Helper function to calculate optimal zoom considering bounds and scale constraints
        function calculateOptimalZoom(bounds, minScale, maxScale) {
            if (!minScale && !maxScale) return null;

            // Calculate what zoom level would fit the bounds
            const boundsZoom = map.getBoundsZoom(bounds);

            let optimalZoom = boundsZoom;

            // Constrain zoom based on scale denominators
            if (minScale) {
                const maxZoom = scaleToZoom(minScale);
                optimalZoom = Math.min(optimalZoom, maxZoom);
            }

            if (maxScale) {
                const minZoom = scaleToZoom(maxScale);
                optimalZoom = Math.max(optimalZoom, minZoom);
            }

            return Math.max(0, Math.min(18, optimalZoom));
        }

        // Function to set up GetFeatureInfo for layer tooltips
        function setupGetFeatureInfo(layerName) {
            // Remove any existing click handlers
            map.off('click', handleMapClick);

            // Add new click handler for the current layer
            map.on('click', function(e) {
                handleMapClick(e, layerName);
            });
        }

        // Function to handle map clicks and fetch feature info
        function handleMapClick(e, layerName) {
            const latlng = e.latlng;
            const zoom = map.getZoom();
            const bounds = map.getBounds();
            const size = map.getSize();

            // Convert click coordinates to pixel coordinates
            const point = map.latLngToContainerPoint(latlng);

            // Build GetFeatureInfo URL
            const getFeatureInfoUrl = buildGetFeatureInfoUrl(
                layerName,
                bounds,
                size.x,
                size.y,
                Math.round(point.x),
                Math.round(point.y)
            );

            // Show loading indicator
            document.getElementById('status').textContent = 'Getting feature info...';
            document.getElementById('status').className = 'status loading';

            // Make GetFeatureInfo request
            fetch(getFeatureInfoUrl)
                .then(response => response.text())
                .then(data => {
                    // Reset status
                    checkLayerVisibility(layerName);

                    // Parse and display feature info
                    displayFeatureInfo(data, latlng);
                })
                .catch(error => {
                    console.log('GetFeatureInfo error:', error);
                    // Reset status
                    checkLayerVisibility(layerName);

                    // Show error popup
                    L.popup()
                        .setLatLng(latlng)
                        .setContent('<div style="padding: 10px;"><strong>No information available</strong><br/>Click elsewhere to try again.</div>')
                        .openOn(map);
                });
        }

        // Function to build GetFeatureInfo URL
        function buildGetFeatureInfoUrl(layerName, bounds, width, height, x, y) {
            const sw = bounds.getSouthWest();
            const ne = bounds.getNorthEast();

            const params = new URLSearchParams({
                'service': 'WMS',
                'version': '1.1.0',
                'request': 'GetFeatureInfo',
                'layers': layerName,
                'query_layers': layerName,
                'styles': '',
                'bbox': `${sw.lng},${sw.lat},${ne.lng},${ne.lat}`,
                'width': width,
                'height': height,
                'format': 'image/png',
                'info_format': 'text/html',
                'srs': 'EPSG:4326',
                'x': x,
                'y': y
            });

            return `{{ WMS_BASE_URL }}?${params.toString()}`;
        }

        // Function to display feature information in a popup
        function displayFeatureInfo(htmlContent, latlng) {
            // Clean up the HTML content
            let content = htmlContent;

            // Check if we got meaningful content
            if (!content || content.trim() === '' ||
                content.includes('no features') ||
                content.includes('No data')) {
                content = '<div style="padding: 10px;"><strong>No information available</strong><br/>This area has no data for the selected layer.</div>';
            } else {
                // Wrap content in a styled container
                content = `<div style="padding: 10px; max-width: 300px; max-height: 400px; overflow-y: auto;">${content}</div>`;
            }

            // Create and show popup
            L.popup({
                maxWidth: 350,
                maxHeight: 450,
                autoPan: true,
                closeButton: true,
                autoClose: false,
                closeOnEscapeKey: true
            })
            .setLatLng(latlng)
            .setContent(content)
            .openOn(map);
        }

        // Function to update WMS layer
        function updateWMSLayer(layerName, opacity) {
            document.getElementById('status').textContent = 'Loading layer...';
            document.getElementById('status').className = 'status loading';

            // Remove existing WMS layer if present
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // Add new WMS layer
            wmsLayer = L.tileLayer.wms('{{ WMS_BASE_URL }}', {
                layers: layerName,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: opacity,
                attribution: 'MARBEFES BBT Database | EMODnet Seabed Habitats',
                tiled: true
            });

            wmsLayer.addTo(map);

            // Set up click events for GetFeatureInfo
            setupGetFeatureInfo(layerName);

            // Update legend
            updateLegend(layerName);

            // Zoom to layer extent (this will handle scale-appropriate zoom)
            zoomToLayerExtent(layerName);

            // Set up zoom level monitoring for layer visibility
            map.on('zoomend', function() {
                checkLayerVisibility(layerName);
            });

            // Update status
            setTimeout(() => {
                checkLayerVisibility(layerName);
            }, 1000);
        }

        // Function to check if layer is visible at current zoom level
        function checkLayerVisibility(layerName) {
            const capabilitiesUrl = '{{ WMS_BASE_URL }}?service=WMS&version=1.3.0&request=GetCapabilities';

            fetch(capabilitiesUrl)
                .then(response => response.text())
                .then(data => {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(data, "text/xml");
                    const layers = xmlDoc.getElementsByTagName('Layer');

                    for (let i = 0; i < layers.length; i++) {
                        const nameElement = layers[i].getElementsByTagName('Name')[0];
                        if (nameElement && nameElement.textContent === layerName) {
                            const minScaleElement = layers[i].getElementsByTagName('MinScaleDenominator')[0];
                            const maxScaleElement = layers[i].getElementsByTagName('MaxScaleDenominator')[0];

                            let minScale = minScaleElement ? parseFloat(minScaleElement.textContent) : null;
                            let maxScale = maxScaleElement ? parseFloat(maxScaleElement.textContent) : null;

                            if (minScale || maxScale) {
                                const currentZoom = map.getZoom();
                                const currentScale = 591659030.4 / Math.pow(2, currentZoom);

                                let statusMsg = 'Layer loaded';
                                let statusClass = 'status';

                                if (minScale && currentScale < minScale) {
                                    statusMsg = 'Zoom out to see this layer';
                                    statusClass = 'status error';
                                } else if (maxScale && currentScale > maxScale) {
                                    statusMsg = 'Zoom in to see this layer';
                                    statusClass = 'status error';
                                }

                                document.getElementById('status').textContent = statusMsg;
                                document.getElementById('status').className = statusClass;
                            } else {
                                document.getElementById('status').textContent = 'Layer loaded';
                                document.getElementById('status').className = 'status';
                            }
                            break;
                        }
                    }
                })
                .catch(error => {
                    document.getElementById('status').textContent = 'Layer loaded';
                    document.getElementById('status').className = 'status';
                });
        }

        // Function to update legend
        function updateLegend(layerName) {
            const legendUrl = `{{ WMS_BASE_URL }}?service=WMS&version=1.1.0&request=GetLegendGraphic&layer=${layerName}&format=image/png`;
            const legendImg = document.getElementById('legend-image');
            const legendContainer = document.getElementById('legend-container');

            // Reset src to avoid cached errors
            legendImg.src = '';

            legendImg.onload = () => {
                legendContainer.style.display = 'block';
            };
            legendImg.onerror = () => {
                // Silently hide legend if not available (common for some WMS layers)
                legendContainer.style.display = 'none';
                console.debug(`Legend not available for layer: ${layerName}`);
            };

            // Set src after handlers are attached
            legendImg.src = legendUrl;
        }

        // Function to load and display vector layer (async optimized)
        async function loadVectorLayer(layerName) {
            try {
                document.getElementById('status').textContent = 'Loading vector layer...';
                document.getElementById('status').className = 'status loading';

                // Determine simplification based on zoom level
                // For zoom < 8 (all BBTs view): use 800m simplification (0.007 degrees ‚âà 800m)
                // For zoom >= 8 (individual BBT): no simplification
                const currentZoom = map.getZoom();
                const simplifyParam = currentZoom < 8 ? '?simplify=0.007' : '';

                console.log(`üîß Loading vector layer with zoom=${currentZoom}, simplification=${simplifyParam ? '800m' : 'none'}`);

                // Fetch GeoJSON for the layer with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000);

                const response = await fetch(`${API_BASE_URL}/vector/layer/${encodeURIComponent(layerName)}${simplifyParam}`, {
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const geojson = await response.json();

                // Clear existing vector layers
                vectorLayerGroup.clearLayers();

                    // Style function based on layer metadata
                    const style = geojson.metadata && geojson.metadata.style ?
                        geojson.metadata.style : {
                            fillColor: '#3388ff',
                            color: '#20B2AA',
                            weight: 2,
                            fillOpacity: 0.4,
                            opacity: 0.8
                        };

                    // Create Leaflet layer
                    const geoJsonLayer = L.geoJSON(geojson, {
                        style: function(feature) {
                            return style;
                        },
                        onEachFeature: function(feature, layer) {
                            // Add popup with enhanced content
                            if (feature.properties) {
                                // Use the same enhanced content as tooltips for consistency
                                let popupContent = generateTooltipContent(feature, currentLayer);

                                // Wrap in popup-appropriate styling
                                popupContent = `<div style="max-width: 400px; max-height: 300px; overflow-y: auto;">${popupContent}</div>`;
                                layer.bindPopup(popupContent);
                            }

                            // Add hover tooltip functionality
                            layer.on('mouseover', function(e) {
                                // Generate tooltip content
                                const tooltipContent = generateTooltipContent(feature, currentLayer);

                                // Create tooltip at mouse position
                                const mousePos = e.originalEvent || e;
                                createTooltip(tooltipContent, mousePos.clientX, mousePos.clientY);
                            });

                            layer.on('mousemove', function(e) {
                                // Update tooltip position as mouse moves
                                const mousePos = e.originalEvent || e;
                                updateTooltip(mousePos.clientX, mousePos.clientY);
                            });

                            layer.on('mouseout', function(e) {
                                // Remove tooltip when mouse leaves
                                removeTooltip();
                            });

                            // Add visual feedback on hover
                            layer.on('mouseover', function(e) {
                                const targetLayer = e.target;
                                if (targetLayer.setStyle) {
                                    targetLayer.setStyle({
                                        weight: 3,
                                        opacity: 1,
                                        fillOpacity: 0.6
                                    });
                                }
                            });

                            layer.on('mouseout', function(e) {
                                const targetLayer = e.target;
                                if (targetLayer.setStyle) {
                                    // Reset to original style
                                    targetLayer.setStyle(style);
                                }
                            });
                        }
                    });

                    // Add to vector layer group
                    vectorLayerGroup.addLayer(geoJsonLayer);

                    // Add to map if not already added
                    if (!map.hasLayer(vectorLayerGroup)) {
                        map.addLayer(vectorLayerGroup);
                    }

                    // Zoom to layer bounds if available
                    if (geojson.metadata && geojson.metadata.bounds) {
                        const bounds = geojson.metadata.bounds;
                        map.fitBounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]]);
                    }

                    // Update status
                    const featureCount = geojson.metadata ? geojson.metadata.feature_count : 'unknown';
                    document.getElementById('status').textContent = `Vector layer loaded (${featureCount} features)`;
                    document.getElementById('status').className = 'status';

                    // Hide legend for vector layers
                    document.getElementById('legend-container').style.display = 'none';

            } catch (error) {
                console.error('Error loading vector layer:', error);
                if (error.name === 'AbortError') {
                    document.getElementById('status').textContent = 'Vector layer loading timed out';
                } else {
                    document.getElementById('status').textContent = 'Error loading vector layer';
                }
                document.getElementById('status').className = 'status error';
            }
        }

        // ‚ö° ASYNC OPTIMIZATION FUNCTIONS ‚ö°

        // Concurrent layer processing for better performance (with simplification support)
        async function loadMultipleLayersConcurrently(layerNames, maxConcurrent = 3) {
            console.log(`üöÄ Loading ${layerNames.length} layers concurrently (max ${maxConcurrent} parallel)`);

            const results = [];
            const errors = [];

            // Determine current zoom for simplification
            const currentZoom = map.getZoom();
            const simplifyParam = currentZoom < 8 ? '?simplify=0.007' : '';
            const simplificationType = currentZoom < 8 ? 'simplified' : 'full';

            // Process in batches to avoid overwhelming the server
            for (let i = 0; i < layerNames.length; i += maxConcurrent) {
                const batch = layerNames.slice(i, i + maxConcurrent);

                const batchPromises = batch.map(async (layerName) => {
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 20000); // 20s timeout

                        const response = await fetch(`${API_BASE_URL}/vector/layer/${encodeURIComponent(layerName)}${simplifyParam}`, {
                            signal: controller.signal
                        });

                        clearTimeout(timeoutId);

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const data = await response.json();
                        return { layerName, data, success: true, simplificationType };
                    } catch (error) {
                        return { layerName, error: error.message, success: false, simplificationType };
                    }
                });

                const batchResults = await Promise.allSettled(batchPromises);
                batchResults.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        if (result.value.success) {
                            results.push(result.value);
                        } else {
                            errors.push(result.value);
                        }
                    } else {
                        errors.push({ layerName: batch[index], error: result.reason?.message || 'Unknown error', success: false });
                    }
                });

                // Brief pause between batches to be server-friendly
                if (i + maxConcurrent < layerNames.length) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }

            return { results, errors };
        }

        // Background preloading for instant layer access
        async function preloadLayersInBackground() {
            try {
                if (!vectorLayers || vectorLayers.length === 0) return;

                console.log('üì¶ Preloading vector layers in background...');
                const layerNames = vectorLayers.map(layer => layer.display_name);
                const { results, errors } = await loadMultipleLayersConcurrently(layerNames, 2);

                // Cache successful results with simplification-aware keys
                window.layerCache = window.layerCache || new Map();
                results.forEach(({ layerName, data, simplificationType }) => {
                    const cacheKey = `${layerName}:${simplificationType}`;
                    window.layerCache.set(cacheKey, data);
                });

                const simplType = results.length > 0 ? results[0].simplificationType : 'unknown';
                console.log(`‚úÖ Cached ${results.length} layers (${simplType}) for instant access`);
                if (errors.length > 0) {
                    console.warn(`‚ö†Ô∏è ${errors.length} layers failed to preload`);
                }

            } catch (error) {
                console.error('‚ùå Background preloading failed:', error);
            }
        }

        // Enhanced layer loading with instant cache access (simplification-aware)
        async function loadVectorLayerFast(layerName) {
            try {
                // Determine current simplification state based on zoom
                const currentZoom = map.getZoom();
                const isSimplified = currentZoom < 8;
                const cacheKey = `${layerName}:${isSimplified ? 'simplified' : 'full'}`;

                // Check cache first for instant loading (with simplification awareness)
                if (window.layerCache && window.layerCache.has(cacheKey)) {
                    console.log(`‚ö° Loading ${layerName} from cache (${isSimplified ? '800m simplified' : 'full detail'})`);
                    const geojson = window.layerCache.get(cacheKey);

                    // Process immediately from cache
                    await processVectorLayerData(geojson, layerName);
                    return;
                }

                // Fallback to regular loading (which will apply simplification)
                console.log(`üì° Loading ${layerName} from server (cache miss, ${isSimplified ? '800m simplified' : 'full detail'})`);
                await loadVectorLayer(layerName);

            } catch (error) {
                console.error(`‚ùå Failed to load layer ${layerName}:`, error);
                document.getElementById('status').textContent = `Failed to load ${layerName}`;
                document.getElementById('status').className = 'status error';
            }
        }

        // Helper to process vector layer data efficiently
        async function processVectorLayerData(geojson, layerName) {
            // Clear existing layers
            vectorLayerGroup.clearLayers();

            const style = geojson.metadata?.style || {
                fillColor: '#3388ff',
                color: '#20B2AA',
                weight: 2,
                fillOpacity: 0.4,
                opacity: 0.8
            };

            // Create optimized GeoJSON layer
            const geoJsonLayer = L.geoJSON(geojson, {
                style: () => style,
                onEachFeature: function(feature, layer) {
                    // Enhanced popup creation
                    if (feature.properties) {
                        // Use the same enhanced content as tooltips for consistency
                        let popupContent = generateTooltipContent(feature, layerName);

                        // Wrap in popup-appropriate styling
                        popupContent = `<div style="max-width: 400px; max-height: 300px; overflow-y: auto;">${popupContent}</div>`;
                        layer.bindPopup(popupContent);
                    }

                    // Optimized hover effects
                    layer.on({
                        mouseover: (e) => {
                            const tooltip = generateTooltipContent(feature, layerName);
                            createTooltip(tooltip, e.originalEvent.pageX, e.originalEvent.pageY);
                            layer.setStyle({ weight: style.weight + 2, fillOpacity: (style.fillOpacity || 0.4) + 0.2 });
                        },
                        mouseout: () => {
                            removeTooltip();
                            layer.setStyle(style);
                        },
                        mousemove: (e) => updateTooltip(e.originalEvent.pageX, e.originalEvent.pageY)
                    });
                }
            });

            vectorLayerGroup.addLayer(geoJsonLayer);

            if (!map.hasLayer(vectorLayerGroup)) {
                map.addLayer(vectorLayerGroup);
            }

            // Zoom to bounds if available
            if (geojson.metadata?.bounds) {
                const [minX, minY, maxX, maxY] = geojson.metadata.bounds;
                map.fitBounds([[minY, minX], [maxY, maxX]]);
            }

            // Update status
            const featureCount = geojson.metadata?.feature_count || 'unknown';
            document.getElementById('status').textContent = `Vector layer loaded (${featureCount} features)`;
            document.getElementById('status').className = 'status';

            document.getElementById('legend-container').style.display = 'none';
        }

        // Create layer select options
        const layerSelect = document.getElementById('layer-select');

        // Add "None" option for no overlay
        const noneOption = document.createElement('option');
        noneOption.value = 'none';
        noneOption.textContent = 'No Overlay';
        noneOption.selected = false; // EUNIS will be selected by default instead
        layerSelect.appendChild(noneOption);

        // Add WMS layers as overlays
        if (wmsLayers.length > 0) {
            const wmsGroup = document.createElement('optgroup');
            wmsGroup.label = 'EMODnet Overlays';
            wmsLayers.forEach((layer, index) => {
                const option = document.createElement('option');
                option.value = 'wms:' + layer.name;
                option.textContent = layer.title || layer.name;
                wmsGroup.appendChild(option);
            });
            layerSelect.appendChild(wmsGroup);
        }

        // Create HELCOM layer select options
        const helcomSelect = document.getElementById('helcom-select');

        // Add "None" option for no HELCOM overlay
        const helcomNoneOption = document.createElement('option');
        helcomNoneOption.value = 'none';
        helcomNoneOption.textContent = 'No HELCOM Overlay';
        helcomNoneOption.selected = true; // Default selection
        helcomSelect.appendChild(helcomNoneOption);

        // Add HELCOM layers
        if (helcomLayers.length > 0) {
            const helcomGroup = document.createElement('optgroup');
            helcomGroup.label = 'HELCOM Pressures';
            helcomLayers.forEach((layer, index) => {
                const option = document.createElement('option');
                option.value = 'helcom:' + layer.name;
                option.textContent = layer.title || layer.name;
                helcomGroup.appendChild(option);
            });
            helcomSelect.appendChild(helcomGroup);
        }

        // Vector layers are now loaded by default, not shown in dropdown

        // Layer select change handler (now only handles WMS overlays)
        layerSelect.onchange = function(e) {
            const selectedValue = e.target.value;
            if (selectedValue === 'none') {
                // Remove WMS overlay
                if (wmsLayer) {
                    map.removeLayer(wmsLayer);
                    wmsLayer = null;
                }
                // Clear legend
                document.getElementById('legend').innerHTML = '';
                currentLayerType = 'vector'; // Back to vector only
            } else if (selectedValue.startsWith('wms:')) {
                const layerName = selectedValue.substring(4);
                selectWMSLayerAsOverlay(layerName);
            }
        };

        // HELCOM select change handler
        helcomSelect.onchange = function(e) {
            const selectedValue = e.target.value;
            if (selectedValue === 'none') {
                // Remove HELCOM overlay
                if (helcomLayer) {
                    map.removeLayer(helcomLayer);
                    helcomLayer = null;
                }
                currentLayerType = 'vector'; // Back to vector only
            } else if (selectedValue.startsWith('helcom:')) {
                const layerName = selectedValue.substring(7);
                selectHELCOMLayerAsOverlay(layerName);
            }
        };

        // Function to select WMS layer as base layer (original behavior)
        function selectWMSLayer(layerName) {
            currentLayer = layerName;
            currentLayerType = 'wms';

            // Remove any existing tooltip
            removeTooltip();

            // Clear vector layers
            vectorLayerGroup.clearLayers();
            if (map.hasLayer(vectorLayerGroup)) {
                map.removeLayer(vectorLayerGroup);
            }

            // Clear existing WMS layer
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // Add WMS layer
            wmsLayer = L.tileLayer.wms('https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_view/wms', {
                layers: layerName,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: currentOpacity
            });

            wmsLayer.addTo(map);

            // Update legend
            updateLegend(layerName);
        }

        // Function to select WMS layer as overlay (new behavior for dropdown)
        function selectWMSLayerAsOverlay(layerName) {
            currentLayer = layerName;
            currentLayerType = 'wms-overlay';

            // Clear existing WMS layer
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // Add WMS layer as overlay on top of vector layers
            wmsLayer = L.tileLayer.wms('https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_view/wms', {
                layers: layerName,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: currentOpacity
            });

            wmsLayer.addTo(map);

            // Update legend
            updateLegend(layerName);

            // Update status tooltip with detailed information
            const statusTooltip = document.getElementById('emodnet-status-tooltip');
            if (statusTooltip) {
                // Create detailed layer information
                let displayName = '';
                let tooltipDetail = '';

                if (layerName.includes('eunis2019_full')) {
                    displayName = '‚úì EUNIS 2019 Full';
                    tooltipDetail = 'Layer: EUNIS 2019 (Full Resolution)\nSimplification: None\nDetail Level: Maximum\nBest for: Individual BBT areas (zoom >= 8)\nSource: EMODnet Seabed Habitats';
                } else if (layerName.includes('eunis2019_800')) {
                    displayName = '‚úì EUNIS 2019 800m';
                    tooltipDetail = 'Layer: EUNIS 2019 (800m simplification)\nSimplification: 800m\nDetail Level: Simplified\nBest for: All BBTs overview (zoom < 8)\nSource: EMODnet Seabed Habitats';
                } else if (layerName.includes('eusm')) {
                    const simplification = layerName.match(/(\d+)/)?.[0] || 'full';
                    displayName = `‚úì EUNIS ${simplification}m`;
                    tooltipDetail = `Layer: ${layerName}\nSource: EMODnet Seabed Habitats\nFormat: WMS 1.1.0`;
                } else {
                    displayName = `‚úì ${layerName.replace(/_/g, ' ').substring(0, 20)}`;
                    tooltipDetail = `Layer: ${layerName}\nSource: EMODnet Seabed Habitats`;
                }

                statusTooltip.textContent = displayName;
                statusTooltip.title = tooltipDetail;
                statusTooltip.style.color = '#28a745';
                statusTooltip.style.maxWidth = '200px';
            }
        }

        // Function to select HELCOM layer as overlay
        function selectHELCOMLayerAsOverlay(layerName) {
            currentLayer = layerName;
            currentLayerType = 'helcom-overlay';

            // Clear existing HELCOM layer
            if (helcomLayer) {
                map.removeLayer(helcomLayer);
            }

            // Add HELCOM layer as overlay on top of vector layers
            helcomLayer = L.tileLayer.wms('{{ HELCOM_WMS_BASE_URL }}', {
                layers: layerName,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: currentOpacity
            });

            helcomLayer.addTo(map);

            // Clear legend since HELCOM might not have standard legends
            document.getElementById('legend').innerHTML = '';

            // Update status tooltip with detailed information
            const statusTooltip = document.getElementById('helcom-status-tooltip');
            if (statusTooltip) {
                // Extract human-readable layer name
                const shortName = layerName.split(':').pop().replace(/_/g, ' ');
                const displayName = `‚úì ${shortName.substring(0, 25)}${shortName.length > 25 ? '...' : ''}`;
                const tooltipDetail = `Layer: ${shortName}\nSource: HELCOM Baltic Sea\nRegion: Baltic Sea\nFormat: WMS 1.1.0\nFull ID: ${layerName}`;

                statusTooltip.textContent = displayName;
                statusTooltip.title = tooltipDetail;
                statusTooltip.style.color = '#28a745';
                statusTooltip.style.maxWidth = '200px';
            }
        }

        // Function to select vector layer
        function selectVectorLayer(layerName) {
            currentLayer = layerName;
            currentLayerType = 'vector';

            // Remove any existing tooltip
            removeTooltip();

            // Remove WMS layer
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
                wmsLayer = null;
            }

            // Load vector layer
            loadVectorLayer(layerName);
        }

        // Function to select vector layer as base layer
        function selectVectorLayerAsBase(layerName) {
            selectVectorLayer(layerName);
        }

        // Opacity control
        const opacitySlider = document.getElementById('opacity');
        const opacityValue = document.getElementById('opacity-value');

        opacitySlider.oninput = function() {
            currentOpacity = this.value / 100;
            opacityValue.textContent = this.value + '%';

            if ((currentLayerType === 'wms' || currentLayerType === 'wms-overlay') && wmsLayer) {
                wmsLayer.setOpacity(currentOpacity);
            } else if (currentLayerType === 'helcom-overlay' && helcomLayer) {
                helcomLayer.setOpacity(currentOpacity);
            } else if (currentLayerType === 'vector' && map.hasLayer(vectorLayerGroup)) {
                // Update opacity for vector layers
                vectorLayerGroup.eachLayer(function(layer) {
                    if (layer.setStyle) {
                        const currentStyle = layer.options.style || {};
                        layer.setStyle({
                            ...currentStyle,
                            opacity: currentOpacity,
                            fillOpacity: currentOpacity * 0.6  // Slightly more transparent fill
                        });
                    }
                });
            }
        };

        // Base map switcher
        document.getElementById('basemap').onchange = function(e) {
            map.removeLayer(currentBaseMap);
            currentBaseMap = baseMaps[e.target.value];
            currentBaseMap.addTo(map);

            // Move WMS layer to top
            if (wmsLayer) {
                wmsLayer.bringToFront();
            }
        };

        // OLD INITIALIZATION - DISABLED
        // This old code loads WMS layer as base (removes vectors)
        // New initialization at line 2548 handles both BBT + WMS overlay together
        console.log('‚è≠Ô∏è Skipping old WMS-only initialization (using new BBT + WMS overlay method)');

        // // Load initial layer
        // // Load EUSeaMap 2023 EUNIS as the default European marine habitat layer
        // console.log('üåä Loading default layer: EUSeaMap 2023 European Biological Zones');
        // document.getElementById('status').textContent = 'Loading EUSeaMap 2023 Biological Zones...';
        // document.getElementById('status').className = 'status loading';

        // // Load the EUSeaMap 2023 European Biological Zones layer (better performance)
        // try {
        //     selectWMSLayer('eusm2023_bio_full');

        //     // Update layer selection dropdown to show the selected layer
        //     const layerSelect = document.getElementById('layer-select');
        //     if (layerSelect) {
        //         layerSelect.value = `wms:eusm2023_bio_full`;
        //     }
        // } catch (error) {
        //     console.error('Failed to load default layer:', error);
        //     document.getElementById('status').textContent = 'Map ready (WMS service unavailable)';
        //     document.getElementById('status').className = 'status';
        // }

        // // Set up fallback timer for slow WMS loading
        // setTimeout(() => {
        //     const statusEl = document.getElementById('status');
        //     if (statusEl.textContent.includes('Loading')) {
        //         statusEl.textContent = 'Map ready (WMS loading in background)';
        //         statusEl.className = 'status';
        //     }
        // }, 5000); // 5 second timeout

        // Also load vector layers in the background for BBT navigation
        if (vectorSupport && vectorLayers.length > 0) {
            console.log('üöÄ Starting optimized async layer preloading...');
            setTimeout(() => {
                // Use the new concurrent preloading function
                preloadLayersInBackground().then(() => {
                    console.log('‚úÖ Background preloading complete - layers ready for instant access!');
                }).catch(error => {
                    console.error('‚ùå Background preloading failed:', error);
                    // Fallback to old method
                    console.log('üîÑ Falling back to sequential loading...');
                    vectorLayers.forEach(layer => {
                        setTimeout(() => loadVectorLayer(layer.display_name), Math.random() * 1000);
                    });
                });
            }, 1500); // Start preloading slightly earlier
        }

        // Function to load European EuSeaMap layers with fallback
        function loadEuropeanEuSeaMapLayerWithFallback(layerName, opacity) {
            console.log('üì° Attempting to load European EuSeaMap layer with fallback:', layerName);

            // First try the European endpoint
            loadEuropeanEuSeaMapLayer(layerName, opacity);

            // Set up fallback to standard endpoint after timeout
            setTimeout(() => {
                const statusEl = document.getElementById('status');
                if (statusEl.textContent.includes('Loading')) {
                    console.log('‚ö†Ô∏è European endpoint slow, trying fallback layer...');
                    loadFallbackWMSLayer();
                }
            }, 8000); // 8 second timeout before fallback
        }

        // Function to load a fallback WMS layer from standard endpoint
        function loadFallbackWMSLayer() {
            console.log('üì° Loading fallback WMS layer from standard endpoint');

            // Remove existing WMS layer if present
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // Use a known working layer from standard endpoint
            const standardWmsUrl = 'https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_view/wms';
            const fallbackLayer = 'eusm2023_bio_full'; // European Biological Zones (working alternative)

            wmsLayer = L.tileLayer.wms(standardWmsUrl, {
                layers: fallbackLayer,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: currentOpacity,
                attribution: 'MARBEFES BBT Database | EMODnet Seabed Habitats | EUSeaMap 2023 Biological Zones',
                tiled: true,
                timeout: 10000,
                errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='
            });

            // Add error handling for fallback layer
            wmsLayer.on('tileerror', function(e) {
                console.warn('Fallback WMS tile failed:', e.tile.src);
                document.getElementById('status').textContent = 'Map ready (WMS service unavailable)';
                document.getElementById('status').className = 'status';
            });

            wmsLayer.on('tileload', function() {
                document.getElementById('status').textContent = 'EUSeaMap 2023 Biological Zones loaded (fallback)';
                document.getElementById('status').className = 'status success';
            });

            wmsLayer.addTo(map);

            // Set up click events for GetFeatureInfo
            setupGetFeatureInfo(fallbackLayer);

            // Update legend for fallback layer
            updateLegend(fallbackLayer);

            // Update dropdown to reflect actual loaded layer
            const layerSelect = document.getElementById('layer-select');
            if (layerSelect) {
                layerSelect.value = `wms:${fallbackLayer}`;
            }
        }

        // Function to toggle EMODnet panel visibility
        function toggleEmodnetPanel() {
            const panel = document.getElementById('emodnet-panel');
            const icon = document.getElementById('emodnet-toggle-icon');

            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                panel.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

        // Function to toggle HELCOM panel visibility
        function toggleHelcomPanel() {
            const panel = document.getElementById('helcom-panel');
            const icon = document.getElementById('helcom-toggle-icon');

            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                panel.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

        // Function to toggle Advanced Controls panel visibility
        function toggleAdvancedPanel() {
            const panel = document.getElementById('advanced-panel');
            const icon = document.getElementById('advanced-toggle-icon');

            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                panel.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

        // Function to retry loading default layer manually
        function retryDefaultLayer() {
            console.log('üîÑ Manual retry of default layer requested');
            document.getElementById('status').textContent = 'Retrying default layer...';
            document.getElementById('status').className = 'status loading';

            // Remove any existing layer
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // Try loading default layer again
            selectWMSLayer(currentLayer);

            // Update dropdown
            const layerSelect = document.getElementById('layer-select');
            if (layerSelect) {
                layerSelect.value = `wms:${currentLayer}`;
            }
        }

        // Function to load European EuSeaMap layers from the emodnet_open endpoint
        function loadEuropeanEuSeaMapLayer(layerName, opacity) {
            console.log('üì° Loading European EuSeaMap layer:', layerName);

            // Remove existing WMS layer if present
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // European EuSeaMap layers are in the emodnet_open endpoint
            const europeanWmsUrl = 'https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_open/wms';

            // Add new WMS layer from European endpoint with error handling
            wmsLayer = L.tileLayer.wms(europeanWmsUrl, {
                layers: layerName,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: opacity,
                attribution: 'MARBEFES BBT Database | EMODnet Seabed Habitats | EUSeaMap 2023',
                tiled: true,
                timeout: 10000, // 10 second timeout for tile requests
                errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==' // Transparent 1x1 pixel
            });

            // Add error handling for tile loading
            wmsLayer.on('tileerror', function(e) {
                console.warn('WMS tile failed to load:', e.tile.src);
            });

            wmsLayer.on('tileloadstart', function() {
                console.log('WMS tile loading started...');
            });

            wmsLayer.on('tileload', function() {
                document.getElementById('status').textContent = 'EUSeaMap 2023 EUNIS loaded';
                document.getElementById('status').className = 'status success';
            });

            wmsLayer.addTo(map);

            // Set up click events for GetFeatureInfo
            setupGetFeatureInfo(layerName);

            // Update legend - try from European endpoint first
            updateEuropeanLegend(layerName);

            // Set appropriate zoom for European waters
            map.setView([54.0, 10.0], 4);
        }

        // Function to update legend for European layers
        function updateEuropeanLegend(layerName) {
            const europeanWmsUrl = 'https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_open/wms';
            const legendUrl = `${europeanWmsUrl}?service=WMS&version=1.1.0&request=GetLegendGraphic&layer=${layerName}&format=image/png`;
            const legendImg = document.getElementById('legend-image');
            const legendContainer = document.getElementById('legend-container');

            if (legendImg && legendContainer) {
                legendImg.src = legendUrl;
                legendImg.onload = () => {
                    legendContainer.style.display = 'block';
                };
                legendImg.onerror = () => {
                    console.log('European legend not available, trying standard legend...');
                    updateLegend(layerName); // Fallback to standard legend
                };
            }
        }

        // Add scale control
        L.control.scale().addTo(map);

        // Add native Leaflet layers control widget
        var overlayMaps = {
            'BBT Areas': vectorLayerGroup  // BBT vector layer group
        };

        var layersControl = L.control.layers(baseMaps, overlayMaps, {
            position: 'topright',
            collapsed: true  // Collapsed by default - click to expand
        }).addTo(map);

        // Remove tooltips when clicking on empty map areas
        map.on('click', function(e) {
            removeTooltip();
        });

        // ===== AUTOMATIC ZOOM-BASED LAYER SWITCHING =====
        // Ensures optimal EUSeaMap simplification level is visible at all zoom levels
        let autoSwitchEnabled = true;
        let lastAutoSwitchedZoom = -1;

        function getOptimalEUSeaMapLayer(zoom) {
            // Return best EUNIS 2019 layer name based on zoom level
            // Uses 800m simplification for zoom < 8, full resolution for zoom >= 8
            if (zoom < 8) {
                return ['eusm_2023_eunis2019_800', 'eusm_2023_eunis2019_full'];
            } else {
                return ['eusm_2023_eunis2019_full'];
            }
        }

        function switchEUSeaMapLayerByZoom() {
            if (!autoSwitchEnabled) return;
            if (!wmsLayer || !map.hasLayer(wmsLayer)) return;

            const currentZoom = map.getZoom();
            const zoomThreshold = 1; // Only switch if zoom changes by more than this

            if (Math.abs(currentZoom - lastAutoSwitchedZoom) < zoomThreshold) {
                return; // Don't switch for minor zoom changes
            }

            const optimalLayers = getOptimalEUSeaMapLayer(currentZoom);
            const currentLayerName = wmsLayer.options.layers;

            // Check if current layer is still optimal
            if (optimalLayers.includes(currentLayerName)) {
                return; // Current layer is fine
            }

            // Switch to optimal layer
            console.log(`üîÑ Zoom changed to ${currentZoom}, switching to optimal EUSeaMap layer...`);
            const newLayer = optimalLayers[0]; // Try first option

            selectWMSLayerAsOverlay(newLayer);

            // Update dropdown
            const layerSelect = document.getElementById('layer-select');
            if (layerSelect) {
                layerSelect.value = 'wms:' + newLayer;
            }

            lastAutoSwitchedZoom = currentZoom;
            console.log(`‚úÖ Switched to ${newLayer} for zoom ${currentZoom}`);
        }

        // Attach zoom event listener with debouncing
        let zoomSwitchTimeout;
        map.on('zoomend', function() {
            clearTimeout(zoomSwitchTimeout);
            zoomSwitchTimeout = setTimeout(switchEUSeaMapLayerByZoom, 300);
        });

        console.log('üéØ Automatic zoom-based EUSeaMap layer switching enabled');

        // Optimized Direct BBT Area Zoom Function (no zoom bounce)
        function zoomToBBTArea(areaName) {
            console.log('üéØ Zooming directly to BBT area:', areaName);

            // Set manual zoom flag to prevent auto-reload
            isManualZoom = true;
            console.log('üîí Manual zoom mode enabled');

            // Update button states immediately
            document.querySelectorAll('.bbt-nav-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === areaName) {
                    btn.classList.add('active');
                }
            });

            // Set layer selection state
            currentLayer = 'Bbt - Bbt Areas';
            currentLayerType = 'vector';

            // Check if we already have BBT data cached
            if (bbtFeatureData && bbtFeatureData.features) {
                console.log('‚ö° Using cached BBT data for instant zoom');

                // Find the specific feature
                const feature = bbtFeatureData.features.find(f => f.properties.Name === areaName);

                if (feature) {
                    console.log('‚úÖ Found specific BBT feature in cache, zooming instantly...');

                    // Update status
                    document.getElementById('status').textContent = `Zooming to ${areaName}...`;
                    document.getElementById('status').className = 'status loading';

                    // Check if BBT layer is already loaded (optimization: skip re-rendering if already visible)
                    const isBBTLayerLoaded = currentLayer === 'Bbt - Bbt Areas' &&
                                            vectorLayerGroup &&
                                            vectorLayerGroup.getLayers().length > 0;

                    if (!isBBTLayerLoaded) {
                        console.log('üîÑ BBT layer not loaded, loading it now...');
                        // Clear any existing layers first
                        if (typeof vectorLayerGroup !== 'undefined') {
                            vectorLayerGroup.clearLayers();
                        }

                        // Load the complete layer WITHOUT auto-zoom
                        loadVectorLayerWithoutAutoZoom('Bbt - Bbt Areas', bbtFeatureData);
                    } else {
                        console.log('‚ö° BBT layer already loaded, skipping re-render!');
                    }

                    // Zoom directly to the specific feature immediately (no delay needed if layer exists)
                    const zoomDelay = isBBTLayerLoaded ? 0 : 50;
                    setTimeout(() => {
                        zoomDirectlyToBBTFeature(feature, areaName);
                    }, zoomDelay);
                } else {
                    console.log('‚ö†Ô∏è Specific feature not found in cache');
                    zoomToGeneralBBTArea(areaName);
                }
                return;
            }

            // If no cache, fetch the data (first time only)
            console.log('üì° Loading BBT data for first time...');
            document.getElementById('status').textContent = `Loading ${areaName}...`;
            document.getElementById('status').className = 'status loading';

            // Load the BBT vector layer data
            fetch(`${API_BASE_URL}/vector/layer/${encodeURIComponent('Bbt - Bbt Areas')}`)
                .then(response => {
                    console.log('üì• BBT layer API response:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(geojson => {
                    console.log('‚úÖ BBT data loaded, features:', geojson.features ? geojson.features.length : 0);

                    // Store the data for future use
                    bbtFeatureData = geojson;

                    // Find the specific feature
                    const feature = geojson.features.find(f => f.properties.Name === areaName);

                    if (feature) {
                        console.log('‚úÖ Found specific BBT feature, zooming directly...');

                        // Clear any existing layers first
                        if (typeof vectorLayerGroup !== 'undefined') {
                            vectorLayerGroup.clearLayers();
                        }

                        // Load the complete layer WITHOUT auto-zoom
                        loadVectorLayerWithoutAutoZoom('Bbt - Bbt Areas', geojson);

                        // Then zoom directly to the specific feature with optimized timing
                        setTimeout(() => {
                            zoomDirectlyToBBTFeature(feature, areaName);
                        }, 100); // Reduced delay for faster UX
                    } else {
                        console.log('‚ö†Ô∏è Specific feature not found, loading full layer...');
                        // Fallback to fast cached loading
                        loadVectorLayerFast('Bbt - Bbt Areas');
                    }
                })
                .catch(error => {
                    console.error('‚ùå Failed to load BBT data:', error);
                    document.getElementById('status').textContent = `Failed to load ${areaName}`;
                    document.getElementById('status').className = 'status error';

                    // Fallback zoom
                    console.log('üìç Using fallback zoom');
                    zoomToGeneralBBTArea(areaName);
                });
        }

        // Function to zoom to specific feature once layer is loaded
        function zoomToSpecificBBTFeature(areaName) {
            console.log('üîç Looking for BBT feature:', areaName);

            // If we don't have the data yet, load it
            if (!bbtFeatureData) {
                console.log('üì° Loading BBT data to find feature...');
                loadBBTFeatures().then(() => {
                    zoomToSpecificBBTFeature(areaName);
                }).catch((error) => {
                    console.log('‚ö†Ô∏è Could not load BBT data, using general zoom');
                    // Fallback: Just zoom to overall BBT bounds
                    zoomToGeneralBBTArea(areaName);
                });
                return;
            }

            // Find the matching feature
            const feature = bbtFeatureData.features.find(f => f.properties.Name === areaName);
            if (feature) {
                console.log('‚úÖ Found feature, zooming to specific area...');
                zoomToBBTFeature(feature, null);
                document.getElementById('status').textContent = `Zoomed to ${areaName}`;
                document.getElementById('status').className = 'status success';
            } else {
                console.log('‚ö†Ô∏è Feature not found, using general zoom');
                zoomToGeneralBBTArea(areaName);
            }
        }

        // Fallback function for general BBT area zoom
        function zoomToGeneralBBTArea(areaName) {
            console.log('üìç Using general BBT area zoom for:', areaName);

            // Use vector layer bounds if available
            if (vectorLayerGroup && vectorLayerGroup.getLayers().length > 0) {
                const bounds = vectorLayerGroup.getBounds();
                if (bounds.isValid()) {
                    map.fitBounds(bounds, {padding: [20, 20]});
                    document.getElementById('status').textContent = `Showing ${areaName} in BBT layer`;
                    document.getElementById('status').className = 'status success';
                    return;
                }
            }

            // Final fallback: zoom to general European marine area
            map.setView([55.0, 10.0], 4);
            document.getElementById('status').textContent = `Showing general area for ${areaName}`;
            document.getElementById('status').className = 'status warning';
        }

        // Optimized helper function: Direct zoom to BBT feature without bounce
        function zoomDirectlyToBBTFeature(feature, areaName) {
            console.log('üéØ Zooming directly to BBT feature:', areaName);

            // Calculate bounds for the feature
            let bounds = L.latLngBounds();

            if (feature.geometry.type === 'Polygon') {
                feature.geometry.coordinates[0].forEach(coord => {
                    bounds.extend([coord[1], coord[0]]);
                });
            } else if (feature.geometry.type === 'MultiPolygon') {
                feature.geometry.coordinates.forEach(polygon => {
                    polygon[0].forEach(coord => {
                        bounds.extend([coord[1], coord[0]]);
                    });
                });
            }

            // Zoom to the feature bounds with optimal padding
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [30, 30] });

                // Update status
                document.getElementById('status').textContent = `Zoomed to ${areaName}`;
                document.getElementById('status').className = 'status success';

                console.log('‚úÖ Direct zoom completed for:', areaName);

                // Reset manual zoom flag after zoom animation completes (500ms delay)
                setTimeout(() => {
                    isManualZoom = false;
                    console.log('üîì Manual zoom mode disabled');
                }, 500);
            } else {
                console.log('‚ö†Ô∏è Invalid bounds, using fallback zoom');
                zoomToGeneralBBTArea(areaName);

                // Reset flag even on fallback
                setTimeout(() => {
                    isManualZoom = false;
                    console.log('üîì Manual zoom mode disabled (fallback)');
                }, 500);
            }
        }

        // Helper function: Load vector layer without automatic zoom
        function loadVectorLayerWithoutAutoZoom(layerName, geojson) {
            console.log('üìç Loading vector layer without auto-zoom:', layerName);

            // Remove existing vector layers
            if (vectorLayerGroup) {
                vectorLayerGroup.clearLayers();
            }

            // KEEP WMS/HELCOM overlays - don't remove them during BBT navigation
            // Users want to see both BBT shapes and EUSeaMap habitat data together
            console.log('‚úÖ Preserving WMS overlay during BBT zoom');

            // Create GeoJSON layer with styling and interactivity
            const geoJsonLayer = L.geoJSON(geojson, {
                style: function(feature) {
                    const style = geojson.metadata && geojson.metadata.style ?
                                geojson.metadata.style :
                                {
                                    fillColor: '#20B2AA',
                                    color: '#008B8B',
                                    weight: 2,
                                    fillOpacity: 0.4,
                                    opacity: 0.8
                                };
                    return {
                        ...style,
                        opacity: currentOpacity,
                        fillOpacity: currentOpacity * 0.6
                    };
                },
                onEachFeature: function(feature, layer) {
                    // Add hover events for tooltip
                    layer.on('mouseover', function(e) {
                        showTooltip(e, feature);
                    });
                    layer.on('mouseout', function() {
                        removeTooltip();
                    });
                    layer.on('mousemove', function(e) {
                        updateTooltipPosition(e);
                    });
                }
            });

            // Add to vector layer group
            if (!vectorLayerGroup) {
                vectorLayerGroup = L.layerGroup();
            }
            vectorLayerGroup.addLayer(geoJsonLayer);
            vectorLayerGroup.addTo(map);

            // Update layer selection UI
            const vectorSelect = document.getElementById('vector-select');
            if (vectorSelect) {
                vectorSelect.value = layerName;
            }

            // Hide legend for vector layers
            document.getElementById('legend-container').style.display = 'none';

            console.log('‚úÖ Vector layer loaded without auto-zoom');
        }

        // Helper functions for tooltips
        function showTooltip(e, feature) {
            const tooltipContent = generateTooltipContent(feature, currentLayer);
            const mousePos = e.originalEvent || e;
            createTooltip(tooltipContent, mousePos.clientX, mousePos.clientY);
        }

        function updateTooltipPosition(e) {
            const mousePos = e.originalEvent || e;
            updateTooltip(mousePos.clientX, mousePos.clientY);
        }

        // Enhanced BBT Navigation Initialization (background loading)
        async function initializeBBTNavigation() {
            console.log('üöÄ Background loading BBT navigation data...');
            try {
                await loadBBTFeatures(); // Load data in background for future use
                console.log('‚úÖ BBT navigation initialized successfully');
            } catch (error) {
                // Check if it's a 503 error (vector support disabled)
                if (error.message.includes('503')) {
                    console.warn('‚ö†Ô∏è Vector support disabled - BBT navigation unavailable');
                    showBBTLoadingError('BBT features unavailable (vector support disabled)');
                } else {
                    console.error('‚ùå Failed to initialize BBT navigation:', error);
                    showBBTLoadingError('Failed to load BBT features');
                }
            }
        }

        // Background initialization (non-blocking)
        setTimeout(initializeBBTNavigation, 2000);

        // ===== PYDECK / DECK.GL INTEGRATION =====

        let deckInstance = null;
        let pydeckEnabled = false;
        let sampleData = [];

        // Generate sample oceanographic data points
        function generateOceanData() {
            const data = [];
            // Baltic Sea bounds
            const latMin = 53.0, latMax = 66.0;
            const lonMin = 9.0, lonMax = 31.0;

            for (let i = 0; i < 5000; i++) {
                const lat = latMin + Math.random() * (latMax - latMin);
                const lon = lonMin + Math.random() * (lonMax - lonMin);
                data.push({
                    position: [lon, lat],
                    depth: Math.random() * 300 + 10, // 10-310m depth
                    temperature: Math.random() * 15 + 5, // 5-20¬∞C
                    salinity: Math.random() * 10 + 30, // 30-40 PSU
                    chlorophyll: Math.random() * 50 + 0.5, // 0.5-50.5 ¬µg/L
                    biomass: Math.random() * 1000 + 10, // 10-1010 g/m¬≤
                    species_count: Math.floor(Math.random() * 50) + 1
                });
            }
            return data;
        }

        // Color schemes
        const colorSchemes = {
            viridis: [[68, 1, 84], [59, 82, 139], [33, 144, 141], [94, 201, 98], [253, 231, 37]],
            plasma: [[13, 8, 135], [126, 3, 168], [203, 70, 121], [249, 142, 8], [240, 249, 33]],
            ocean: [[0, 119, 190], [0, 180, 216], [144, 224, 239], [173, 232, 244], [240, 249, 232]],
            thermal: [[0, 0, 0], [128, 0, 0], [255, 128, 0], [255, 255, 0], [255, 255, 255]],
            turbo: [[48, 18, 59], [33, 144, 141], [94, 201, 98], [253, 231, 37], [122, 4, 3]]
        };

        // Initialize PyDeck
        function initializePyDeck() {
            if (!window.deck) {
                console.warn('Deck.gl not loaded');
                return;
            }

            sampleData = generateOceanData();

            const mapBounds = map.getBounds();
            const center = map.getCenter();

            deckInstance = new deck.Deck({
                container: 'pydeck-overlay',
                initialViewState: {
                    longitude: center.lng,
                    latitude: center.lat,
                    zoom: map.getZoom() - 1,
                    pitch: 0,
                    bearing: 0
                },
                controller: false, // Let Leaflet handle interaction
                layers: []
            });

            // Sync with Leaflet map movements
            map.on('moveend', syncDeckWithLeaflet);
            map.on('zoomend', syncDeckWithLeaflet);

            console.log('PyDeck initialized with', sampleData.length, 'data points');
        }

        // Sync Deck.gl view with Leaflet map
        function syncDeckWithLeaflet() {
            if (!deckInstance) return;

            const center = map.getCenter();
            const zoom = map.getZoom();
            const viewMode = document.getElementById('view-mode').value;

            let pitch = 0, bearing = 0;

            switch(viewMode) {
                case '3d': pitch = 45; break;
                case 'bird': pitch = 60; break;
                case 'first-person': pitch = 80; bearing = 45; break;
            }

            deckInstance.setProps({
                viewState: {
                    longitude: center.lng,
                    latitude: center.lat,
                    zoom: zoom - 1,
                    pitch: pitch,
                    bearing: bearing
                }
            });
        }

        // Create PyDeck layer based on type
        function createPyDeckLayer(layerType, colorScheme) {
            if (!sampleData.length) return null;

            const colors = colorSchemes[colorScheme] || colorSchemes.viridis;
            const elevationScale = parseInt(document.getElementById('elevation-scale').value);
            const radiusScale = parseInt(document.getElementById('radius-scale').value);

            switch(layerType) {
                case 'hexagon':
                    return new deck.HexagonLayer({
                        id: 'hexagon-layer',
                        data: sampleData,
                        pickable: true,
                        extruded: true,
                        radius: radiusScale,
                        elevationScale: elevationScale / 100,
                        elevationRange: [0, 1000],
                        colorRange: colors,
                        getPosition: d => d.position,
                        getElevationWeight: d => d.biomass,
                        getColorWeight: d => d.depth
                    });

                case 'heatmap':
                    return new deck.HeatmapLayer({
                        id: 'heatmap-layer',
                        data: sampleData,
                        getPosition: d => d.position,
                        getWeight: d => d.temperature,
                        radiusPixels: 60,
                        colorRange: colors
                    });

                case 'grid':
                    return new deck.GridLayer({
                        id: 'grid-layer',
                        data: sampleData,
                        pickable: true,
                        extruded: true,
                        cellSize: radiusScale * 2,
                        elevationScale: elevationScale / 50,
                        colorRange: colors,
                        getPosition: d => d.position,
                        getElevationWeight: d => d.chlorophyll,
                        getColorWeight: d => d.salinity
                    });

                case 'contour':
                    return new deck.ContourLayer({
                        id: 'contour-layer',
                        data: sampleData,
                        cellSize: radiusScale * 3,
                        getPosition: d => d.position,
                        getWeight: d => d.depth,
                        contours: [
                            {threshold: 50, color: colors[0]},
                            {threshold: 100, color: colors[1]},
                            {threshold: 150, color: colors[2]},
                            {threshold: 200, color: colors[3]},
                            {threshold: 250, color: colors[4]}
                        ]
                    });

                case 'column':
                    return new deck.ColumnLayer({
                        id: 'column-layer',
                        data: sampleData.slice(0, 1000), // Limit for performance
                        diskResolution: 12,
                        radius: radiusScale / 2,
                        extruded: true,
                        pickable: true,
                        elevationScale: elevationScale,
                        getPosition: d => d.position,
                        getFillColor: d => {
                            const temp = d.temperature;
                            const colorIndex = Math.floor((temp / 20) * (colors.length - 1));
                            return colors[Math.min(colorIndex, colors.length - 1)];
                        },
                        getElevation: d => d.biomass
                    });

                default:
                    return null;
            }
        }

        // Update PyDeck visualization
        function updatePyDeckVisualization() {
            if (!pydeckEnabled || !deckInstance) return;

            const layerType = document.getElementById('pydeck-layer').value;
            const colorScheme = document.getElementById('color-scheme').value;

            let layers = [];
            if (layerType !== 'none') {
                const layer = createPyDeckLayer(layerType, colorScheme);
                if (layer) layers.push(layer);
            }

            deckInstance.setProps({ layers });
            syncDeckWithLeaflet();
        }

        // Event handlers for PyDeck controls
        document.getElementById('enable-3d').onchange = function(e) {
            pydeckEnabled = e.target.checked;
            const overlay = document.getElementById('pydeck-overlay');

            if (pydeckEnabled) {
                if (!deckInstance) initializePyDeck();
                overlay.style.pointerEvents = 'auto';
                updatePyDeckVisualization();
                document.getElementById('status').textContent = 'PyDeck 3D visualization enabled';
            } else {
                overlay.style.pointerEvents = 'none';
                if (deckInstance) deckInstance.setProps({ layers: [] });
                document.getElementById('status').textContent = 'PyDeck 3D visualization disabled';
            }
        };

        document.getElementById('pydeck-layer').onchange = updatePyDeckVisualization;
        document.getElementById('color-scheme').onchange = updatePyDeckVisualization;
        document.getElementById('view-mode').onchange = syncDeckWithLeaflet;

        document.getElementById('elevation-scale').oninput = function() {
            document.getElementById('elevation-value').textContent = this.value + 'x';
            if (pydeckEnabled) updatePyDeckVisualization();
        };

        document.getElementById('radius-scale').oninput = function() {
            document.getElementById('radius-value').textContent = this.value + 'm';
            if (pydeckEnabled) updatePyDeckVisualization();
        };

        // Theme switching functionality
        function changeTheme(themeName) {
            console.log('üé® Changing theme to:', themeName);
            document.body.setAttribute('data-theme', themeName);

            // Save theme preference to localStorage
            localStorage.setItem('selected-theme', themeName);

            // Update status to show theme changed
            const statusEl = document.getElementById('status');
            const currentStatus = statusEl.textContent;
            statusEl.textContent = `Theme changed to ${themeName.charAt(0).toUpperCase() + themeName.slice(1)}`;
            statusEl.className = 'status';

            // Restore original status after 2 seconds
            setTimeout(() => {
                statusEl.textContent = currentStatus;
            }, 2000);
        }

        // Initialize theme from localStorage or default to ocean
        function initializeTheme() {
            const savedTheme = localStorage.getItem('selected-theme') || 'ocean';
            document.body.setAttribute('data-theme', savedTheme);

            // Update the select element to match
            const themeSelect = document.getElementById('theme');
            if (themeSelect) {
                themeSelect.value = savedTheme;
            }

            console.log('üé® Theme initialized:', savedTheme);
        }

        // Theme selector change handler
        document.getElementById('theme').onchange = function(e) {
            changeTheme(e.target.value);
        };

        // Initialize theme on page load
        initializeTheme();

        // Auto-load BBT vector layers and EUSeaMap 400m overlay on page startup
        function initializeVectorLayers() {
            console.log('üöÄ Auto-loading BBT vector layers on startup...');
            console.log('üìä Vector layers data:', vectorLayers);
            console.log('üìä Vector support:', vectorSupport);

            if (vectorLayers && vectorLayers.length > 0) {
                // Load the main BBT layer by default
                const bbtLayer = vectorLayers.find(layer =>
                    layer.display_name && (layer.display_name.includes('Bbt Areas') || layer.display_name.includes('BBT'))
                );

                if (bbtLayer) {
                    console.log('üìç Loading primary BBT layer:', bbtLayer.display_name);
                    loadVectorLayerFast(bbtLayer.display_name);
                } else if (vectorLayers.length > 0) {
                    // Fallback to first available layer
                    console.log('üìç Loading first available vector layer:', vectorLayers[0].display_name);
                    loadVectorLayerFast(vectorLayers[0].display_name);
                }
            } else {
                console.warn('‚ö†Ô∏è No vector layers available for auto-loading. vectorLayers:', vectorLayers);
            }

            // Auto-load EUNIS 2019 800m as overlay for all BBTs overview
            setTimeout(() => {
                const defaultWMSLayer = 'eusm_2023_eunis2019_800';

                console.log('üåä Auto-loading EUNIS 2019 800m overlay (optimized for all BBTs view)...');
                selectWMSLayerAsOverlay(defaultWMSLayer);

                // Update dropdown selection to reflect the loaded layer
                const layerSelect = document.getElementById('layer-select');
                if (layerSelect) {
                    layerSelect.value = 'wms:' + defaultWMSLayer;
                }

                console.log('‚úÖ Default layers loaded: BBT vectors + EUNIS 2019 800m (simplified for overview)');
            }, 1500);
        }

        // Initialize vector layers after a brief delay to ensure DOM is ready
        setTimeout(initializeVectorLayers, 1000);

        // Zoom-based EUNIS & Vector layer switching: 800m for overview, full for individual BBTs
        let currentEunisLayer = 'eusm_2023_eunis2019_800'; // Track current layer
        let lastZoomLevel = map.getZoom();
        let lastVectorSimplification = lastZoomLevel < 8 ? 'simplified' : 'full'; // Track vector simplification state
        let isManualZoom = false; // Flag to prevent auto-reload during manual BBT zoom

        map.on('zoomend', function() {
            const currentZoom = map.getZoom();
            let targetLayer = null;
            let needsVectorReload = false;

            // Determine which layer should be active based on zoom level
            if (currentZoom >= 8) {
                // Zoomed in to individual BBT - use full resolution
                targetLayer = 'eusm_2023_eunis2019_full';

                // Check if we need to reload vectors from simplified to full
                if (lastVectorSimplification === 'simplified') {
                    needsVectorReload = true;
                    lastVectorSimplification = 'full';
                }
            } else {
                // Zoomed out to all BBTs - use 800m simplified
                targetLayer = 'eusm_2023_eunis2019_800';

                // Check if we need to reload vectors from full to simplified
                if (lastVectorSimplification === 'full') {
                    needsVectorReload = true;
                    lastVectorSimplification = 'simplified';
                }
            }

            // Switch WMS layer if needed
            if (targetLayer !== currentEunisLayer) {
                const previousLayer = currentEunisLayer;
                currentEunisLayer = targetLayer;

                if (currentZoom >= 8) {
                    console.log(`üîç Zoom level ${currentZoom}: Switching to EUNIS 2019 Full Resolution (individual BBT detail)`);
                } else {
                    console.log(`üó∫Ô∏è Zoom level ${currentZoom}: Switching to EUNIS 2019 800m (all BBTs overview)`);
                }

                selectWMSLayerAsOverlay(targetLayer);

                // Update dropdown selection
                const layerSelect = document.getElementById('layer-select');
                if (layerSelect) {
                    layerSelect.value = 'wms:' + targetLayer;
                }

                console.log(`‚úÖ WMS Layer switched: ${previousLayer} ‚Üí ${targetLayer}`);
            }

            // Reload vector layers if simplification state changed (but NOT during manual BBT zoom)
            if (needsVectorReload && vectorLayers && vectorLayers.length > 0 && !isManualZoom) {
                const bbtLayer = vectorLayers.find(layer =>
                    layer.display_name.includes('Bbt Areas') ||
                    layer.display_name.includes('BBT')
                );

                if (bbtLayer) {
                    const simplification = currentZoom < 8 ? '800m' : 'full detail';
                    console.log(`üîÑ Reloading BBT vector layer with ${simplification}...`);
                    loadVectorLayerFast(bbtLayer.display_name);
                }
            } else if (isManualZoom) {
                console.log(`‚è≠Ô∏è Skipping auto-reload during manual BBT zoom`);
            }

            lastZoomLevel = currentZoom;
        });

    </script>
    <!-- BBT Data Popup Modal -->
    <div class="bbt-popup-overlay" id="bbt-popup-overlay">
        <div class="bbt-popup">
            <div class="bbt-popup-header">
                <h2 class="bbt-popup-title" id="bbt-popup-title">BBT Data</h2>
                <button class="bbt-popup-close" onclick="closeBBTDataPopup()">√ó</button>
            </div>
            <div class="bbt-popup-content" id="bbt-popup-content">
                <!-- Dynamic content populated by JavaScript -->
            </div>
            <div class="bbt-popup-actions">
                <button class="bbt-popup-btn bbt-popup-btn-cancel" onclick="closeBBTDataPopup()">Cancel</button>
                <button class="bbt-popup-btn bbt-popup-btn-save" onclick="saveBBTData()">Save Changes</button>
            </div>
        </div>
    </div>

    <script>
        // BBT Data storage (in-memory for now, can be saved to backend later)
        let bbtDataStore = {};

        // Editable template for BBT data
        const bbtDataTemplate = {
            location: '',
            coordinates: '',
            depth_range: '',
            habitat_type: '',
            sampling_date: '',
            research_team: '',
            species_count: '',
            biodiversity_index: '',
            environmental_status: '',
            notes: ''
        };

        // Initialize BBT data for each location
        function initializeBBTData() {
            const bbtLocations = [
                'Archipelago', 'Balearic', 'Bay of Gdansk', 'Gulf of Biscay',
                'Heraklion', 'Hornsund', 'Kongsfjord', 'Lithuanian coastal zone', 'Sardinia'
            ];

            bbtLocations.forEach(location => {
                if (!bbtDataStore[location]) {
                    bbtDataStore[location] = {
                        ...bbtDataTemplate,
                        location: location
                    };
                }
            });
        }

        // Open BBT data popup
        function openBBTDataPopup(bbtName) {
            console.log('üìä Opening BBT data popup for:', bbtName);
            console.log('üìä Available bathymetry data:', Object.keys(bathymetryStats));

            // Initialize if not done
            if (Object.keys(bbtDataStore).length === 0) {
                initializeBBTData();
            }

            // Get or create data for this BBT
            if (!bbtDataStore[bbtName]) {
                bbtDataStore[bbtName] = {
                    ...bbtDataTemplate,
                    location: bbtName
                };
            }

            const data = bbtDataStore[bbtName];

            // Update popup title
            document.getElementById('bbt-popup-title').textContent = `${bbtName} - BBT Data`;

            // Generate bathymetry stats section if available
            const bbtStats = bathymetryStats[bbtName];
            console.log(`üåä Bathymetry lookup for "${bbtName}":`, bbtStats);
            console.log(`üåä Stats available: ${bbtStats ? 'YES' : 'NO'}`);
            const bathymetrySection = bbtStats ? `
                <div class="bbt-data-section" style="background-color: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin-top: 0; color: #1976d2; font-size: 16px; margin-bottom: 10px;">
                        üåä Bathymetry Statistics
                    </h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                        <div>
                            <strong>Min Depth:</strong> ${bbtStats.min_depth_m} m
                        </div>
                        <div>
                            <strong>Max Depth:</strong> ${bbtStats.max_depth_m} m
                        </div>
                        <div>
                            <strong>Avg Depth:</strong> ${bbtStats.avg_depth_m} m
                        </div>
                        <div>
                            <strong>Depth Range:</strong> ${(bbtStats.max_depth_m - bbtStats.min_depth_m).toFixed(1)} m
                        </div>
                    </div>
                    ${bbtStats.notes ? `<div style="font-style: italic; color: #555; margin-bottom: 8px;">${bbtStats.notes}</div>` : ''}
                    <div style="font-size: 12px; color: #666;">
                        Source: ${bbtStats.sample_count ? 'EMODnet Bathymetry (sampled)' : 'Manual bathymetric data'}
                    </div>
                </div>
            ` : '';

            // Generate form fields
            const content = `
                <div class="bbt-data-field">
                    <label for="bbt-location">Location</label>
                    <input type="text" id="bbt-location" value="${data.location}" readonly>
                </div>
                ${bathymetrySection}
                <div class="bbt-data-field">
                    <label for="bbt-coordinates">Coordinates (Lat, Lon)</label>
                    <input type="text" id="bbt-coordinates" value="${data.coordinates}" placeholder="e.g., 60.5, 25.2">
                </div>
                <div class="bbt-data-field">
                    <label for="bbt-depth">Depth Range (m)</label>
                    <input type="text" id="bbt-depth" value="${data.depth_range}" placeholder="e.g., 10-50m">
                </div>
                <div class="bbt-data-field">
                    <label for="bbt-habitat">Habitat Type</label>
                    <select id="bbt-habitat">
                        <option value="">Select habitat type</option>
                        <option value="Rocky reef" ${data.habitat_type === 'Rocky reef' ? 'selected' : ''}>Rocky reef</option>
                        <option value="Sandy bottom" ${data.habitat_type === 'Sandy bottom' ? 'selected' : ''}>Sandy bottom</option>
                        <option value="Muddy bottom" ${data.habitat_type === 'Muddy bottom' ? 'selected' : ''}>Muddy bottom</option>
                        <option value="Mixed sediment" ${data.habitat_type === 'Mixed sediment' ? 'selected' : ''}>Mixed sediment</option>
                        <option value="Seagrass meadow" ${data.habitat_type === 'Seagrass meadow' ? 'selected' : ''}>Seagrass meadow</option>
                        <option value="Kelp forest" ${data.habitat_type === 'Kelp forest' ? 'selected' : ''}>Kelp forest</option>
                    </select>
                </div>
                <div class="bbt-data-field">
                    <label for="bbt-sampling-date">Last Sampling Date</label>
                    <input type="date" id="bbt-sampling-date" value="${data.sampling_date}">
                </div>
                <div class="bbt-data-field">
                    <label for="bbt-research-team">Research Team</label>
                    <input type="text" id="bbt-research-team" value="${data.research_team}" placeholder="e.g., Institute Name">
                </div>
                <div class="bbt-data-field">
                    <label for="bbt-species-count">Species Count</label>
                    <input type="number" id="bbt-species-count" value="${data.species_count}" placeholder="Number of species">
                </div>
                <div class="bbt-data-field">
                    <label for="bbt-biodiversity">Biodiversity Index</label>
                    <input type="text" id="bbt-biodiversity" value="${data.biodiversity_index}" placeholder="e.g., Shannon index">
                </div>
                <div class="bbt-data-field">
                    <label for="bbt-env-status">Environmental Status</label>
                    <select id="bbt-env-status">
                        <option value="">Select status</option>
                        <option value="Excellent" ${data.environmental_status === 'Excellent' ? 'selected' : ''}>Excellent</option>
                        <option value="Good" ${data.environmental_status === 'Good' ? 'selected' : ''}>Good</option>
                        <option value="Moderate" ${data.environmental_status === 'Moderate' ? 'selected' : ''}>Moderate</option>
                        <option value="Poor" ${data.environmental_status === 'Poor' ? 'selected' : ''}>Poor</option>
                        <option value="Bad" ${data.environmental_status === 'Bad' ? 'selected' : ''}>Bad</option>
                    </select>
                </div>
                <div class="bbt-data-field">
                    <label for="bbt-notes">Additional Notes</label>
                    <textarea id="bbt-notes" placeholder="Enter any additional observations or notes...">${data.notes}</textarea>
                </div>
            `;

            document.getElementById('bbt-popup-content').innerHTML = content;
            console.log(`üåä Bathymetry section included: ${bathymetrySection ? 'YES' : 'NO'}`);
            console.log(`üåä Content length: ${content.length} characters`);

            // Store current BBT name for saving
            document.getElementById('bbt-popup-overlay').dataset.currentBbt = bbtName;

            // Show popup
            document.getElementById('bbt-popup-overlay').classList.add('active');
        }

        // Close BBT data popup
        function closeBBTDataPopup() {
            document.getElementById('bbt-popup-overlay').classList.remove('active');
        }

        // Save BBT data
        function saveBBTData() {
            const bbtName = document.getElementById('bbt-popup-overlay').dataset.currentBbt;

            if (!bbtName) {
                console.error('No BBT name found for saving');
                return;
            }

            // Collect data from form
            const updatedData = {
                location: document.getElementById('bbt-location').value,
                coordinates: document.getElementById('bbt-coordinates').value,
                depth_range: document.getElementById('bbt-depth').value,
                habitat_type: document.getElementById('bbt-habitat').value,
                sampling_date: document.getElementById('bbt-sampling-date').value,
                research_team: document.getElementById('bbt-research-team').value,
                species_count: document.getElementById('bbt-species-count').value,
                biodiversity_index: document.getElementById('bbt-biodiversity').value,
                environmental_status: document.getElementById('bbt-env-status').value,
                notes: document.getElementById('bbt-notes').value
            };

            // Save to store
            bbtDataStore[bbtName] = updatedData;

            console.log('üíæ Saved BBT data for', bbtName, updatedData);

            // TODO: Send data to backend API
            // fetch(`${API_BASE_URL}/bbt/data/${encodeURIComponent(bbtName)}`, {
            //     method: 'POST',
            //     headers: { 'Content-Type': 'application/json' },
            //     body: JSON.stringify(updatedData)
            // });

            // Show success message
            alert(`‚úÖ Data saved successfully for ${bbtName}!`);

            // Close popup
            closeBBTDataPopup();
        }

        // Close popup when clicking outside
        document.getElementById('bbt-popup-overlay').addEventListener('click', function(e) {
            if (e.target === this) {
                closeBBTDataPopup();
            }
        });

        // Close popup with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const overlay = document.getElementById('bbt-popup-overlay');
                if (overlay.classList.contains('active')) {
                    closeBBTDataPopup();
                }
            }
        });

        // Initialize BBT data on page load
        initializeBBTData();
    </script>

</body>
</html>