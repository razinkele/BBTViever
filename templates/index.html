<!DOCTYPE html>
<html>
<head>
    <title>MARBEFES BBT Database</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-geometryutil@0.10.1/src/leaflet.geometryutil.js"></script>

    <!-- PyDeck/Deck.gl Dependencies -->
    <script src="https://unpkg.com/deck.gl@^8.9.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/layers@^8.9.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/geo-layers@^8.9.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/aggregation-layers@^8.9.0/dist.min.js"></script>
    <style>
        :root {
            /* Ocean Blue Theme (default) */
            --primary-color: #20B2AA;
            --secondary-color: #008B8B;
            --accent-color: #40E0D0;
            --sidebar-bg: linear-gradient(135deg, #f8f9ff 0%, #e3f2fd 50%, #f0f8ff 100%);
            --card-bg: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(248,249,250,0.95) 100%);
            --text-color: #2F4F4F;
            --border-color: rgba(32, 178, 170, 0.2);
            --shadow-color: rgba(32, 178, 170, 0.15);
        }

        [data-theme="forest"] {
            --primary-color: #228B22;
            --secondary-color: #006400;
            --accent-color: #32CD32;
            --sidebar-bg: linear-gradient(135deg, #f0fff0 0%, #e6ffe6 50%, #f5fff5 100%);
            --card-bg: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(240,255,240,0.95) 100%);
            --text-color: #1F4F1F;
            --border-color: rgba(34, 139, 34, 0.2);
            --shadow-color: rgba(34, 139, 34, 0.15);
        }

        [data-theme="sunset"] {
            --primary-color: #FF8C00;
            --secondary-color: #FF6347;
            --accent-color: #FFD700;
            --sidebar-bg: linear-gradient(135deg, #fff8f0 0%, #ffe6cc 50%, #fff4e6 100%);
            --card-bg: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,248,240,0.95) 100%);
            --text-color: #8B4513;
            --border-color: rgba(255, 140, 0, 0.2);
            --shadow-color: rgba(255, 140, 0, 0.15);
        }

        [data-theme="midnight"] {
            --primary-color: #6A5ACD;
            --secondary-color: #483D8B;
            --accent-color: #9370DB;
            --sidebar-bg: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --card-bg: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            --text-color: #E6E6FA;
            --border-color: rgba(106, 90, 205, 0.3);
            --shadow-color: rgba(106, 90, 205, 0.2);
        }

        [data-theme="arctic"] {
            --primary-color: #4682B4;
            --secondary-color: #5F9EA0;
            --accent-color: #87CEEB;
            --sidebar-bg: linear-gradient(135deg, #ffffff 0%, #f8f8ff 50%, #f0f8ff 100%);
            --card-bg: linear-gradient(135deg, rgba(255,255,255,0.95) 0%, rgba(248,248,255,0.98) 100%);
            --text-color: #2F4F4F;
            --border-color: rgba(70, 130, 180, 0.2);
            --shadow-color: rgba(70, 130, 180, 0.1);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f0f0;
            color: var(--text-color);
        }
        #container {
            display: flex;
            height: 100vh;
        }
        #sidebar {
            width: 320px;
            background: var(--sidebar-bg);
            padding: 20px;
            box-shadow: 2px 0 15px var(--shadow-color);
            overflow-y: auto;
            z-index: 1000;
            border-right: 1px solid var(--border-color);
        }
        #map {
            flex: 1;
            position: relative;
        }
        h1 {
            color: #2F4F4F;
            font-size: 24px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .logo {
            height: 40px;
            width: auto;
            margin-right: 12px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .help-icon {
            font-size: 18px;
            color: #20B2AA;
            cursor: help;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
            white-space: pre-line;
        }
        .help-icon:hover {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.5);
            transform: scale(1.1);
        }
        .subtitle {
            color: #7f8c8d;
            font-size: 12px;
            margin-bottom: 15px;
        }

        .project-info {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 3px 12px var(--shadow-color);
        }

        .project-links {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
        }

        .project-links a {
            color: #20B2AA;
            text-decoration: none;
            padding: 4px 8px;
            background: white;
            border-radius: 4px;
            font-size: 11px;
            border: 1px solid #dee2e6;
            transition: all 0.2s ease;
        }

        .project-links a:hover {
            background: #20B2AA;
            color: white;
            transform: translateY(-1px);
        }

        .grant-info {
            text-align: center;
            color: #6c757d;
            font-style: italic;
        }

        .bbt-nav-section {
            margin-bottom: 20px;
        }

        .bbt-nav-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 10px;
        }

        .bbt-nav-btn {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: var(--button-text-color);
            border: none;
            padding: 6px 10px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            box-shadow: 0 2px 4px var(--shadow-color);
            text-transform: capitalize;
            min-width: fit-content;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bbt-nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--primary-color) 100%);
        }

        .bbt-nav-btn:active {
            transform: translateY(0px);
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .bbt-nav-btn.active {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--primary-color) 100%);
            box-shadow: 0 2px 6px var(--shadow-color);
        }
        h3 {
            color: var(--text-color);
            font-size: 16px;
            margin-top: 20px;
            margin-bottom: 10px;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 5px;
        }

        #info {
            background: linear-gradient(135deg, #20B2AA 0%, #008B8B 100%);
            color: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 13px;
            line-height: 1.6;
        }
        .controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #495057;
            font-weight: 600;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--input-bg);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }
        .value-display {
            text-align: center;
            font-size: 14px;
            color: var(--primary-color);
            font-weight: bold;
            margin-top: 5px;
        }
        .legend-container {
            margin-top: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .legend-container h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #495057;
        }
        #legend-image {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        .status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 12px;
            color: #20B2AA;
            font-weight: 600;
        }
        .loading {
            color: #FF8C00;
        }
        .error {
            color: #CD5C5C;
        }

        /* Custom popup styling */
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .leaflet-popup-content {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .leaflet-popup-content h1, .leaflet-popup-content h2, .leaflet-popup-content h3 {
            color: #2F4F4F;
            margin-top: 0;
        }
        .leaflet-popup-content table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .leaflet-popup-content th, .leaflet-popup-content td {
            padding: 4px 8px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        .leaflet-popup-content th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        /* Hover tooltip styles */
        .vector-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            white-space: nowrap;
            transform: translateX(-50%);
        }

        .vector-tooltip .tooltip-title {
            font-weight: bold;
            margin-bottom: 4px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 4px;
        }

        .vector-tooltip .tooltip-area {
            color: #90EE90;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1>
                <img src="/logo/marbefes_02.png" alt="MARBEFES Logo" class="logo">
                MARBEFES BBT Database
                <span class="help-icon" title="MARBEFES BBT Database&#10;&#10;‚Ä¢ Browse Broad Belt Transect (BBT) vector data layers&#10;‚Ä¢ View EMODnet seabed habitat data overlays&#10;‚Ä¢ Access HELCOM Baltic Sea environmental pressure data&#10;‚Ä¢ Use your mouse to pan and zoom the map&#10;‚Ä¢ Click on features for detailed information&#10;‚Ä¢ Hover over BBT polygons for area calculations">‚ìò</span>
            </h1>
            <div class="subtitle">Marine Biodiversity and Ecosystem Functioning leading to Ecosystem Services</div>
            <div class="project-info">
                <div class="project-links">
                    <a href="https://marbefes.eu" target="_blank" title="Visit MARBEFES Project Website">üåê marbefes.eu</a>
                    <a href="https://cordis.europa.eu/project/id/101060937" target="_blank" title="View on CORDIS">üìã CORDIS</a>
                    <a href="https://marbefes.lifewatch.eu" target="_blank" title="MARBEFES Toolbox">üîß Toolbox</a>
                </div>
                <div class="grant-info">
                    <small>Horizon Europe Grant Agreement No. 101060937</small>
                </div>
            </div>

            <h3>BBT Quick Navigation</h3>
            <div class="bbt-nav-section">
                <div class="bbt-nav-buttons" id="bbt-nav-buttons">
                    <!-- Instantly functional BBT buttons -->
                    <button class="bbt-nav-btn" onclick="zoomToBBTArea('Archipelago')" title="üó∫Ô∏è Zoom to Archipelago BBT area">Archipelago</button>
                    <button class="bbt-nav-btn" onclick="zoomToBBTArea('Balearic')" title="üó∫Ô∏è Zoom to Balearic BBT area">Balearic</button>
                    <button class="bbt-nav-btn" onclick="zoomToBBTArea('Bay of Gdansk')" title="üó∫Ô∏è Zoom to Bay of Gdansk BBT area">Bay of Gdansk</button>
                    <button class="bbt-nav-btn" onclick="zoomToBBTArea('Gulf of Biscay')" title="üó∫Ô∏è Zoom to Gulf of Biscay BBT area">Gulf of Biscay</button>
                    <button class="bbt-nav-btn" onclick="zoomToBBTArea('Heraklion')" title="üó∫Ô∏è Zoom to Heraklion BBT area">Heraklion</button>
                    <button class="bbt-nav-btn" onclick="zoomToBBTArea('Hornsund')" title="üó∫Ô∏è Zoom to Hornsund BBT area">Hornsund</button>
                    <button class="bbt-nav-btn" onclick="zoomToBBTArea('Kongsfjord')" title="üó∫Ô∏è Zoom to Kongsfjord BBT area">Kongsfjord</button>
                    <button class="bbt-nav-btn" onclick="zoomToBBTArea('Lithuanian coastal zone')" title="üó∫Ô∏è Zoom to Lithuanian coastal zone BBT area">Lithuanian coastal zone</button>
                    <button class="bbt-nav-btn" onclick="zoomToBBTArea('Sardinia')" title="üó∫Ô∏è Zoom to Sardinia BBT area">Sardinia</button>
                    <div class="loading-indicator" id="bbt-loading" style="color: #20B2AA; font-size: 10px; padding: 4px; text-align: center; margin-top: 8px; display: none;">
                        üîÑ Loading enhanced features...
                    </div>
                </div>
            </div>

            <h3>Available Layers</h3>
            <div class="control-group">
                <label for="layer-select">Select EMODnet Overlay</label>
                <select id="layer-select" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                </select>
            </div>

            <div class="control-group">
                <label for="helcom-select">Select HELCOM Overlay</label>
                <select id="helcom-select" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                </select>
            </div>

            <div class="control-group">
                <button id="retry-default-btn" onclick="retryDefaultLayer()" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #20B2AA; background: #20B2AA; color: white; cursor: pointer; font-size: 12px; margin-top: 5px;">
                    üîÑ Retry Default Layer
                </button>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="opacity">Layer Opacity</label>
                    <input type="range" id="opacity" min="0" max="100" value="70">
                    <div class="value-display" id="opacity-value">70%</div>
                </div>

                <div class="control-group">
                    <label for="basemap">Base Map</label>
                    <select id="basemap" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                        <option value="emodnet_bathymetry">EMODnet Bathymetry</option>
                        <option value="osm">OpenStreetMap</option>
                        <option value="satellite" selected>Satellite</option>
                        <option value="ocean">Ocean</option>
                        <option value="light">Light Gray</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="theme">UI Theme</label>
                    <select id="theme" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                        <option value="ocean" selected>Ocean Blue</option>
                        <option value="forest">Forest Green</option>
                        <option value="sunset">Sunset Orange</option>
                        <option value="midnight">Midnight Dark</option>
                        <option value="arctic">Arctic White</option>
                    </select>
                </div>

                <!-- PyDeck 3D Visualization Controls -->
                <div class="control-group">
                    <h4 style="margin: 15px 0 10px 0; color: #2F4F4F; font-size: 14px; border-bottom: 1px solid #20B2AA; padding-bottom: 5px;">3D Visualization</h4>

                    <div style="margin-bottom: 10px;">
                        <label for="enable-3d">
                            <input type="checkbox" id="enable-3d" style="margin-right: 8px;">
                            Enable 3D View
                        </label>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label for="pydeck-layer">PyDeck Layer Type</label>
                        <select id="pydeck-layer" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                            <option value="none">None</option>
                            <option value="hexagon">Hexagon Aggregation</option>
                            <option value="heatmap">Heatmap</option>
                            <option value="grid">Grid Layer</option>
                            <option value="contour">Contour Layer</option>
                            <option value="column">3D Column Chart</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label for="elevation-scale">Elevation Scale</label>
                        <input type="range" id="elevation-scale" min="1" max="10000" value="1000" style="width: 100%;">
                        <div class="value-display" id="elevation-value">1000x</div>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label for="radius-scale">Point Radius</label>
                        <input type="range" id="radius-scale" min="100" max="5000" value="1000" style="width: 100%;">
                        <div class="value-display" id="radius-value">1000m</div>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label for="color-scheme">Color Scheme</label>
                        <select id="color-scheme" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                            <option value="viridis">Viridis (Blue-Green-Yellow)</option>
                            <option value="plasma">Plasma (Purple-Pink-Yellow)</option>
                            <option value="ocean">Ocean (Blue-Cyan-White)</option>
                            <option value="thermal">Thermal (Black-Red-Yellow)</option>
                            <option value="turbo">Turbo (Blue-Cyan-Green-Yellow-Red)</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label for="view-mode">Camera View</label>
                        <select id="view-mode" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                            <option value="2d">2D (Top Down)</option>
                            <option value="3d">3D (Perspective)</option>
                            <option value="bird">Bird's Eye</option>
                            <option value="first-person">First Person</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="legend-container" id="legend-container" style="display: none;">
                <h4>Legend</h4>
                <img id="legend-image" src="" alt="Layer legend">
            </div>
        </div>

        <div id="map"></div>
        <div id="pydeck-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 400;"></div>
        <div class="status" id="status">Ready</div>
    </div>

    <script>
        // Initialize map
        var map = L.map('map').setView([54.0, 10.0], 4);

        // Base maps
        var baseMaps = {
            'emodnet_bathymetry': L.tileLayer('https://tiles.emodnet-bathymetry.eu/latest/mean_atlas_land/web_mercator/{z}/{x}/{y}.png', {
                attribution: '¬© EMODnet Bathymetry | Marine data from European seas',
                minZoom: 0,
                maxZoom: 18
            }),
            'osm': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }),
            'satellite': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri'
            }),
            'ocean': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri'
            }),
            'light': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                attribution: '¬© CartoDB'
            })
        };

        // Add default base map
        var currentBaseMap = baseMaps['satellite'];
        currentBaseMap.addTo(map);

        // Layer data
        const wmsLayers = {{ layers | tojson }};
        const helcomLayers = {{ helcom_layers | tojson }};
        const vectorLayers = {{ vector_layers | tojson }};
        const vectorSupport = {{ vector_support | tojson }};

        let currentLayer = 'eusm_2023_eunis2019_full'; // Default to EUSeaMap 2023 EUNIS 2019 classification (full resolution)
        let currentLayerType = 'wms';
        let currentOpacity = 0.7;
        let wmsLayer = null;
        let helcomLayer = null;
        let vectorLayerGroup = L.layerGroup();

        // BBT Navigation variables
        let bbtFeatureData = null;
        let currentActiveBBT = null;
        let hoverTooltip = null;

        // BBT Navigation Functions
        async function loadBBTFeatures() {
            console.log('üîÑ Loading BBT features from API...');

            try {
                const apiUrl = '/api/vector/layer/' + encodeURIComponent('Bbts - Broad Belt Transects');
                console.log('üì° Fetching from URL:', apiUrl);

                const response = await fetch(apiUrl);
                console.log('üì• API Response status:', response.status);

                if (response.ok) {
                    bbtFeatureData = await response.json();
                    console.log('‚úÖ BBT features loaded successfully:', bbtFeatureData.features ? bbtFeatureData.features.length : 0, 'features');

                    // Only call createBBTNavigationButtons in background loading mode
                    // Buttons are now created statically in HTML
                    console.log('‚ÑπÔ∏è BBT data ready for zoom operations');

                    return bbtFeatureData;
                } else {
                    const errorText = await response.text();

                    // Handle 503 (service unavailable) as a warning, not an error
                    if (response.status === 503) {
                        console.warn('‚ö†Ô∏è Vector service unavailable:', response.status, response.statusText);
                    } else {
                        console.error('‚ùå API Error:', response.status, response.statusText, errorText);
                    }

                    throw new Error(`API Error: ${response.status}`);
                }
            } catch (error) {
                // Only log as error if it's not a 503 (service unavailable)
                if (!error.message.includes('503')) {
                    console.error('‚ùå Network Error loading BBT features:', error);
                }
                throw error;
            }
        }

        function showBBTLoadingError(message) {
            const buttonsContainer = document.getElementById('bbt-nav-buttons');
            if (buttonsContainer) {
                buttonsContainer.innerHTML = `
                    <div style="color: #CD5C5C; font-size: 11px; padding: 8px; text-align: center; border: 1px solid #CD5C5C; border-radius: 4px; background: #f0f8ff;">
                        ‚ö†Ô∏è ${message}
                        <br><small><a href="#" onclick="loadBBTFeatures(); return false;" style="color: #20B2AA;">Try again</a></small>
                    </div>
                `;
            }
        }

        function createBBTNavigationButtons() {
            console.log('‚úÖ Upgrading BBT navigation buttons to interactive mode...');

            if (!bbtFeatureData || !bbtFeatureData.features) {
                console.error('No BBT feature data available');
                showBBTLoadingError('No feature data available');
                return;
            }

            const buttonsContainer = document.getElementById('bbt-nav-buttons');
            if (!buttonsContainer) {
                console.error('BBT buttons container not found');
                return;
            }

            console.log(`Found ${bbtFeatureData.features.length} BBT features to create buttons for`);

            // Show loading indicator
            const loadingElement = document.getElementById('bbt-loading');
            if (loadingElement) {
                loadingElement.style.display = 'block';
            }

            // Get all existing buttons (fallback buttons)
            const existingButtons = buttonsContainer.querySelectorAll('.bbt-nav-btn');
            console.log(`Found ${existingButtons.length} existing buttons to upgrade`);

            // Create feature lookup by name for easy matching
            const featuresByName = {};
            bbtFeatureData.features.forEach(feature => {
                const name = feature.properties.Name;
                if (name) {
                    featuresByName[name] = feature;
                }
            });

            let upgradeCount = 0;

            // Upgrade existing buttons with interactive functionality
            existingButtons.forEach((button, index) => {
                const buttonText = button.textContent.trim();
                const matchingFeature = featuresByName[buttonText];

                if (matchingFeature) {
                    // Replace the onclick with our interactive function
                    button.onclick = () => zoomToBBTFeature(matchingFeature, button);
                    button.title = `üó∫Ô∏è Zoom to ${buttonText} BBT area`;

                    // Add visual indication that it's now interactive
                    button.style.position = 'relative';

                    console.log(`‚úÖ Upgraded button: "${buttonText}"`);
                    upgradeCount++;
                } else {
                    console.warn(`‚ö†Ô∏è No matching feature found for button: "${buttonText}"`);
                }
            });

            // Hide loading indicator
            if (loadingElement) {
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                }, 500);
            }

            console.log(`‚úÖ Successfully upgraded ${upgradeCount} BBT navigation buttons to interactive mode!`);

            // Final verification
            setTimeout(() => {
                const allButtons = buttonsContainer.querySelectorAll('.bbt-nav-btn');
                console.log(`‚úÖ Final verification: ${allButtons.length} interactive buttons ready`);

                // Add subtle animation to show they're now interactive
                allButtons.forEach((btn, idx) => {
                    btn.style.transition = 'all 0.3s ease';
                    setTimeout(() => {
                        btn.style.transform = 'scale(1.05)';
                        setTimeout(() => {
                            btn.style.transform = 'scale(1)';
                        }, 200);
                    }, idx * 50);
                });
            }, 600);
        }

        function zoomToBBTFeature(feature, buttonElement) {
            if (!feature.geometry) return;

            // Calculate bounds for the feature
            let bounds = L.latLngBounds();

            if (feature.geometry.type === 'Polygon') {
                feature.geometry.coordinates[0].forEach(coord => {
                    bounds.extend([coord[1], coord[0]]);
                });
            } else if (feature.geometry.type === 'MultiPolygon') {
                feature.geometry.coordinates.forEach(polygon => {
                    polygon[0].forEach(coord => {
                        bounds.extend([coord[1], coord[0]]);
                    });
                });
            }

            // Zoom to the feature bounds
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [20, 20] });

                // Update active button state
                document.querySelectorAll('.bbt-nav-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                buttonElement.classList.add('active');
                currentActiveBBT = feature.properties.Name;

                // Update status
                document.getElementById('status').textContent = `Zoomed to ${feature.properties.Name}`;

                // Auto-load vector layer if not already loaded
                if (currentLayerType !== 'vector' || !vectorLayerGroup.getLayers().length) {
                    selectVectorLayerAsBase('Bbts - Broad Belt Transects');
                }
            }
        }

        // Function to calculate area of a feature in square kilometers
        function calculateFeatureArea(feature) {
            if (!feature.geometry) return null;

            try {
                // Use Leaflet's built-in area calculation for polygons
                let area = 0;

                if (feature.geometry.type === 'Polygon') {
                    const coords = feature.geometry.coordinates[0];
                    area = L.GeometryUtil ? L.GeometryUtil.geodesicArea(coords.map(c => L.latLng(c[1], c[0]))) : 0;
                } else if (feature.geometry.type === 'MultiPolygon') {
                    feature.geometry.coordinates.forEach(polygon => {
                        const coords = polygon[0];
                        area += L.GeometryUtil ? L.GeometryUtil.geodesicArea(coords.map(c => L.latLng(c[1], c[0]))) : 0;
                    });
                }

                // Convert from square meters to square kilometers
                return area > 0 ? (area / 1000000).toFixed(2) : null;
            } catch (error) {
                // Fallback: simple bounding box area calculation
                if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                    try {
                        const layer = L.geoJSON(feature);
                        const bounds = layer.getBounds();
                        const area = (bounds.getEast() - bounds.getWest()) * (bounds.getNorth() - bounds.getSouth()) * 12321; // Rough conversion
                        return area > 0 ? area.toFixed(2) : null;
                    } catch (e) {
                        return null;
                    }
                }
                return null;
            }
        }

        // Function to create hover tooltip
        function createTooltip(content, x, y) {
            removeTooltip();

            hoverTooltip = document.createElement('div');
            hoverTooltip.className = 'vector-tooltip';
            hoverTooltip.innerHTML = content;
            hoverTooltip.style.left = x + 'px';
            hoverTooltip.style.top = (y - 10) + 'px';

            document.body.appendChild(hoverTooltip);
        }

        // Function to remove hover tooltip
        function removeTooltip() {
            if (hoverTooltip) {
                document.body.removeChild(hoverTooltip);
                hoverTooltip = null;
            }
        }

        // Function to update tooltip position
        function updateTooltip(x, y) {
            if (hoverTooltip) {
                hoverTooltip.style.left = x + 'px';
                hoverTooltip.style.top = (y - 10) + 'px';
            }
        }

        // Enhanced BBT region information from MARBEFES project
        const bbtRegionInfo = {
            'Archipelago': {
                region: 'Baltic Sea',
                description: 'Marine ecosystem functioning in the Swedish archipelago region',
                habitat: 'Coastal archipelago with complex habitat mosaic',
                research_focus: 'Benthic-pelagic coupling in coastal zones'
            },
            'Balearic': {
                region: 'Mediterranean Sea',
                description: 'Subtropical Mediterranean marine biodiversity hotspot',
                habitat: 'Mediterranean endemic species and Posidonia meadows',
                research_focus: 'Climate change impacts on Mediterranean ecosystems'
            },
            'Bay of Gdansk': {
                region: 'Baltic Sea',
                description: 'Semi-enclosed bay ecosystem with riverine influence',
                habitat: 'Brackish water transitional zone',
                research_focus: 'Land-sea connectivity and nutrient cycling'
            },
            'Gulf of Biscay': {
                region: 'Atlantic Ocean',
                description: 'Continental shelf ecosystem with upwelling dynamics',
                habitat: 'Deep-water Atlantic marine communities',
                research_focus: 'Ocean-shelf biodiversity gradients'
            },
            'Heraklion': {
                region: 'Mediterranean Sea',
                description: 'Eastern Mediterranean oligotrophic ecosystem',
                habitat: 'Deep Mediterranean basinal communities',
                research_focus: 'Deep-sea connectivity and endemic biodiversity'
            },
            'Hornsund': {
                region: 'Arctic Ocean',
                description: 'High Arctic fjord system with glacial influence',
                habitat: 'Arctic marine communities under climate change',
                research_focus: 'Arctic ecosystem resilience and tipping points'
            },
            'Kongsfjord': {
                region: 'Arctic Ocean',
                description: 'Arctic-Atlantic transition zone in Svalbard',
                habitat: 'Arctic-boreal species transition zone',
                research_focus: 'Climate-driven Arctic "atlantification"'
            },
            'Lithuanian coastal zone': {
                region: 'Baltic Sea',
                description: 'Shallow coastal ecosystem with freshwater inputs',
                habitat: 'Sandy coastal waters with estuarine influence',
                research_focus: 'Coastal zone management and eutrophication'
            },
            'Sardinia': {
                region: 'Mediterranean Sea',
                description: 'Western Mediterranean island ecosystem',
                habitat: 'Mediterranean shelf communities and canyons',
                research_focus: 'Island biogeography and connectivity'
            }
        };

        // Function to generate enhanced tooltip content for BBT features with MARBEFES context
        function generateTooltipContent(feature, layerName) {
            let content = '';

            if (layerName && layerName.toLowerCase().includes('bbt')) {
                // Special handling for BBT layers with MARBEFES context
                const siteName = feature.properties?.Name || feature.properties?.name;
                const siteInfo = siteName ? bbtRegionInfo[siteName] : null;

                content += '<div class="tooltip-title">üåä MARBEFES Broad Belt Transect</div>';

                if (siteName) {
                    content += `<div style="font-weight: 600; color: #FFFFFF; margin: 4px 0;">${siteName}</div>`;
                }

                // Calculate area
                const area = calculateFeatureArea(feature);
                if (area) {
                    content += `<div class="tooltip-area">üìê Area: ${area} km¬≤</div>`;
                }

                // Add MARBEFES project context
                if (siteInfo) {
                    content += `<div style="margin: 8px 0; padding: 6px; background: rgba(32, 178, 170, 0.1); border-radius: 4px;">`;
                    content += `<div style="font-size: 11px; color: #20B2AA; font-weight: 600;">üó∫Ô∏è ${siteInfo.region}</div>`;
                    content += `<div style="font-size: 10px; margin-top: 2px; color: #E2E8F0;">${siteInfo.description}</div>`;
                    content += `<div style="font-size: 10px; margin-top: 3px; color: #CBD5E0;"><strong>Habitat:</strong> ${siteInfo.habitat}</div>`;
                    content += `<div style="font-size: 10px; margin-top: 2px; color: #CBD5E0;"><strong>Research:</strong> ${siteInfo.research_focus}</div>`;
                    content += `</div>`;
                } else {
                    // Generic MARBEFES info if specific site not found
                    content += `<div style="margin: 8px 0; padding: 6px; background: rgba(32, 178, 170, 0.1); border-radius: 4px;">`;
                    content += `<div style="font-size: 10px; color: #E2E8F0;">Part of the MARBEFES project studying marine biodiversity across European seas from river-to-ocean gradients.</div>`;
                    content += `</div>`;
                }




            } else {
                // Generic vector layer tooltip
                content += '<div class="tooltip-title">Vector Feature</div>';
                const area = calculateFeatureArea(feature);
                if (area) {
                    content += `<div class="tooltip-area">Area: ${area} km¬≤</div>`;
                }

                // Show first few properties
                if (feature.properties) {
                    const propEntries = Object.entries(feature.properties).slice(0, 3);
                    propEntries.forEach(([key, value]) => {
                        if (value !== null && value !== undefined && value !== '') {
                            content += `<div>${key}: ${value}</div>`;
                        }
                    });
                }
            }

            return content;
        }

        // Function to zoom to layer extent with scale awareness
        function zoomToLayerExtent(layerName) {
            // Get layer bounds from WMS GetCapabilities
            const capabilitiesUrl = '{{ WMS_BASE_URL }}?service=WMS&version=1.3.0&request=GetCapabilities';

            fetch(capabilitiesUrl)
                .then(response => response.text())
                .then(data => {
                    // Parse XML
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(data, "text/xml");

                    // Find the layer
                    const layers = xmlDoc.getElementsByTagName('Layer');
                    for (let i = 0; i < layers.length; i++) {
                        const nameElement = layers[i].getElementsByTagName('Name')[0];
                        if (nameElement && nameElement.textContent === layerName) {

                            // Extract scale denominators for the layer
                            let minScale = null;
                            let maxScale = null;

                            const minScaleElement = layers[i].getElementsByTagName('MinScaleDenominator')[0];
                            const maxScaleElement = layers[i].getElementsByTagName('MaxScaleDenominator')[0];

                            if (minScaleElement) {
                                minScale = parseFloat(minScaleElement.textContent);
                            }
                            if (maxScaleElement) {
                                maxScale = parseFloat(maxScaleElement.textContent);
                            }

                            // Look for BoundingBox or EX_GeographicBoundingBox
                            let boundingBox = layers[i].getElementsByTagName('EX_GeographicBoundingBox')[0];
                            if (!boundingBox) {
                                boundingBox = layers[i].getElementsByTagName('LatLonBoundingBox')[0];
                            }

                            if (boundingBox) {
                                let west, south, east, north;

                                // Try EX_GeographicBoundingBox format (WMS 1.3.0)
                                const westBound = boundingBox.getElementsByTagName('westBoundLongitude')[0];
                                const southBound = boundingBox.getElementsByTagName('southBoundLatitude')[0];
                                const eastBound = boundingBox.getElementsByTagName('eastBoundLongitude')[0];
                                const northBound = boundingBox.getElementsByTagName('northBoundLatitude')[0];

                                if (westBound && southBound && eastBound && northBound) {
                                    west = parseFloat(westBound.textContent);
                                    south = parseFloat(southBound.textContent);
                                    east = parseFloat(eastBound.textContent);
                                    north = parseFloat(northBound.textContent);
                                } else {
                                    // Try LatLonBoundingBox format (WMS 1.1.1)
                                    west = parseFloat(boundingBox.getAttribute('minx'));
                                    south = parseFloat(boundingBox.getAttribute('miny'));
                                    east = parseFloat(boundingBox.getAttribute('maxx'));
                                    north = parseFloat(boundingBox.getAttribute('maxy'));
                                }

                                if (!isNaN(west) && !isNaN(south) && !isNaN(east) && !isNaN(north)) {
                                    // Calculate appropriate zoom level based on scale constraints
                                    const bounds = [[south, west], [north, east]];

                                    // Calculate zoom level that respects scale constraints
                                    let targetZoom = calculateOptimalZoom(bounds, minScale, maxScale);

                                    if (targetZoom) {
                                        // Use calculated zoom level
                                        const center = [(south + north) / 2, (west + east) / 2];
                                        map.setView(center, targetZoom);
                                    } else {
                                        // Fallback to fitBounds with constraints
                                        const fitOptions = { padding: [20, 20] };

                                        // Apply zoom constraints if available
                                        if (minScale || maxScale) {
                                            if (minScale) fitOptions.maxZoom = scaleToZoom(minScale);
                                            if (maxScale) fitOptions.minZoom = scaleToZoom(maxScale);
                                        }

                                        map.fitBounds(bounds, fitOptions);
                                    }
                                    return;
                                }
                            }
                            break;
                        }
                    }

                    // Fallback to European waters if no bounds found
                    map.setView([54.0, 10.0], 4);
                })
                .catch(error => {
                    console.log('Could not get layer extent:', error);
                    // Fallback to European waters
                    map.setView([54.0, 10.0], 4);
                });
        }

        // Helper function to convert scale denominator to approximate zoom level
        function scaleToZoom(scale) {
            // Approximate conversion: scale = 591659030.4 / (2^zoom)
            // This is based on Web Mercator projection at equator
            const baseScale = 591659030.4;
            const zoom = Math.log2(baseScale / scale);
            return Math.max(0, Math.min(18, Math.round(zoom)));
        }

        // Helper function to calculate optimal zoom considering bounds and scale constraints
        function calculateOptimalZoom(bounds, minScale, maxScale) {
            if (!minScale && !maxScale) return null;

            // Calculate what zoom level would fit the bounds
            const boundsZoom = map.getBoundsZoom(bounds);

            let optimalZoom = boundsZoom;

            // Constrain zoom based on scale denominators
            if (minScale) {
                const maxZoom = scaleToZoom(minScale);
                optimalZoom = Math.min(optimalZoom, maxZoom);
            }

            if (maxScale) {
                const minZoom = scaleToZoom(maxScale);
                optimalZoom = Math.max(optimalZoom, minZoom);
            }

            return Math.max(0, Math.min(18, optimalZoom));
        }

        // Function to set up GetFeatureInfo for layer tooltips
        function setupGetFeatureInfo(layerName) {
            // Remove any existing click handlers
            map.off('click', handleMapClick);

            // Add new click handler for the current layer
            map.on('click', function(e) {
                handleMapClick(e, layerName);
            });
        }

        // Function to handle map clicks and fetch feature info
        function handleMapClick(e, layerName) {
            const latlng = e.latlng;
            const zoom = map.getZoom();
            const bounds = map.getBounds();
            const size = map.getSize();

            // Convert click coordinates to pixel coordinates
            const point = map.latLngToContainerPoint(latlng);

            // Build GetFeatureInfo URL
            const getFeatureInfoUrl = buildGetFeatureInfoUrl(
                layerName,
                bounds,
                size.x,
                size.y,
                Math.round(point.x),
                Math.round(point.y)
            );

            // Show loading indicator
            document.getElementById('status').textContent = 'Getting feature info...';
            document.getElementById('status').className = 'status loading';

            // Make GetFeatureInfo request
            fetch(getFeatureInfoUrl)
                .then(response => response.text())
                .then(data => {
                    // Reset status
                    checkLayerVisibility(layerName);

                    // Parse and display feature info
                    displayFeatureInfo(data, latlng);
                })
                .catch(error => {
                    console.log('GetFeatureInfo error:', error);
                    // Reset status
                    checkLayerVisibility(layerName);

                    // Show error popup
                    L.popup()
                        .setLatLng(latlng)
                        .setContent('<div style="padding: 10px;"><strong>No information available</strong><br/>Click elsewhere to try again.</div>')
                        .openOn(map);
                });
        }

        // Function to build GetFeatureInfo URL
        function buildGetFeatureInfoUrl(layerName, bounds, width, height, x, y) {
            const sw = bounds.getSouthWest();
            const ne = bounds.getNorthEast();

            const params = new URLSearchParams({
                'service': 'WMS',
                'version': '1.1.0',
                'request': 'GetFeatureInfo',
                'layers': layerName,
                'query_layers': layerName,
                'styles': '',
                'bbox': `${sw.lng},${sw.lat},${ne.lng},${ne.lat}`,
                'width': width,
                'height': height,
                'format': 'image/png',
                'info_format': 'text/html',
                'srs': 'EPSG:4326',
                'x': x,
                'y': y
            });

            return `{{ WMS_BASE_URL }}?${params.toString()}`;
        }

        // Function to display feature information in a popup
        function displayFeatureInfo(htmlContent, latlng) {
            // Clean up the HTML content
            let content = htmlContent;

            // Check if we got meaningful content
            if (!content || content.trim() === '' ||
                content.includes('no features') ||
                content.includes('No data')) {
                content = '<div style="padding: 10px;"><strong>No information available</strong><br/>This area has no data for the selected layer.</div>';
            } else {
                // Wrap content in a styled container
                content = `<div style="padding: 10px; max-width: 300px; max-height: 400px; overflow-y: auto;">${content}</div>`;
            }

            // Create and show popup
            L.popup({
                maxWidth: 350,
                maxHeight: 450,
                autoPan: true,
                closeButton: true,
                autoClose: false,
                closeOnEscapeKey: true
            })
            .setLatLng(latlng)
            .setContent(content)
            .openOn(map);
        }

        // Function to update WMS layer
        function updateWMSLayer(layerName, opacity) {
            document.getElementById('status').textContent = 'Loading layer...';
            document.getElementById('status').className = 'status loading';

            // Remove existing WMS layer if present
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // Add new WMS layer
            wmsLayer = L.tileLayer.wms('{{ WMS_BASE_URL }}', {
                layers: layerName,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: opacity,
                attribution: 'MARBEFES BBT Database | EMODnet Seabed Habitats',
                tiled: true
            });

            wmsLayer.addTo(map);

            // Set up click events for GetFeatureInfo
            setupGetFeatureInfo(layerName);

            // Update legend
            updateLegend(layerName);

            // Zoom to layer extent (this will handle scale-appropriate zoom)
            zoomToLayerExtent(layerName);

            // Set up zoom level monitoring for layer visibility
            map.on('zoomend', function() {
                checkLayerVisibility(layerName);
            });

            // Update status
            setTimeout(() => {
                checkLayerVisibility(layerName);
            }, 1000);
        }

        // Function to check if layer is visible at current zoom level
        function checkLayerVisibility(layerName) {
            const capabilitiesUrl = '{{ WMS_BASE_URL }}?service=WMS&version=1.3.0&request=GetCapabilities';

            fetch(capabilitiesUrl)
                .then(response => response.text())
                .then(data => {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(data, "text/xml");
                    const layers = xmlDoc.getElementsByTagName('Layer');

                    for (let i = 0; i < layers.length; i++) {
                        const nameElement = layers[i].getElementsByTagName('Name')[0];
                        if (nameElement && nameElement.textContent === layerName) {
                            const minScaleElement = layers[i].getElementsByTagName('MinScaleDenominator')[0];
                            const maxScaleElement = layers[i].getElementsByTagName('MaxScaleDenominator')[0];

                            let minScale = minScaleElement ? parseFloat(minScaleElement.textContent) : null;
                            let maxScale = maxScaleElement ? parseFloat(maxScaleElement.textContent) : null;

                            if (minScale || maxScale) {
                                const currentZoom = map.getZoom();
                                const currentScale = 591659030.4 / Math.pow(2, currentZoom);

                                let statusMsg = 'Layer loaded';
                                let statusClass = 'status';

                                if (minScale && currentScale < minScale) {
                                    statusMsg = 'Zoom out to see this layer';
                                    statusClass = 'status error';
                                } else if (maxScale && currentScale > maxScale) {
                                    statusMsg = 'Zoom in to see this layer';
                                    statusClass = 'status error';
                                }

                                document.getElementById('status').textContent = statusMsg;
                                document.getElementById('status').className = statusClass;
                            } else {
                                document.getElementById('status').textContent = 'Layer loaded';
                                document.getElementById('status').className = 'status';
                            }
                            break;
                        }
                    }
                })
                .catch(error => {
                    document.getElementById('status').textContent = 'Layer loaded';
                    document.getElementById('status').className = 'status';
                });
        }

        // Function to update legend
        function updateLegend(layerName) {
            const legendUrl = `{{ WMS_BASE_URL }}?service=WMS&version=1.1.0&request=GetLegendGraphic&layer=${layerName}&format=image/png`;
            const legendImg = document.getElementById('legend-image');
            const legendContainer = document.getElementById('legend-container');

            // Reset src to avoid cached errors
            legendImg.src = '';

            legendImg.onload = () => {
                legendContainer.style.display = 'block';
            };
            legendImg.onerror = () => {
                // Silently hide legend if not available (common for some WMS layers)
                legendContainer.style.display = 'none';
                console.debug(`Legend not available for layer: ${layerName}`);
            };

            // Set src after handlers are attached
            legendImg.src = legendUrl;
        }

        // Function to load and display vector layer (async optimized)
        async function loadVectorLayer(layerName) {
            try {
                document.getElementById('status').textContent = 'Loading vector layer...';
                document.getElementById('status').className = 'status loading';

                // Fetch GeoJSON for the layer with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000);

                const response = await fetch(`/api/vector/layer/${encodeURIComponent(layerName)}`, {
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const geojson = await response.json();

                // Clear existing vector layers
                vectorLayerGroup.clearLayers();

                    // Style function based on layer metadata
                    const style = geojson.metadata && geojson.metadata.style ?
                        geojson.metadata.style : {
                            fillColor: '#3388ff',
                            color: '#20B2AA',
                            weight: 2,
                            fillOpacity: 0.4,
                            opacity: 0.8
                        };

                    // Create Leaflet layer
                    const geoJsonLayer = L.geoJSON(geojson, {
                        style: function(feature) {
                            return style;
                        },
                        onEachFeature: function(feature, layer) {
                            // Add popup with enhanced content
                            if (feature.properties) {
                                // Use the same enhanced content as tooltips for consistency
                                let popupContent = generateTooltipContent(feature, currentLayer);

                                // Wrap in popup-appropriate styling
                                popupContent = `<div style="max-width: 400px; max-height: 300px; overflow-y: auto;">${popupContent}</div>`;
                                layer.bindPopup(popupContent);
                            }

                            // Add hover tooltip functionality
                            layer.on('mouseover', function(e) {
                                // Generate tooltip content
                                const tooltipContent = generateTooltipContent(feature, currentLayer);

                                // Create tooltip at mouse position
                                const mousePos = e.originalEvent || e;
                                createTooltip(tooltipContent, mousePos.clientX, mousePos.clientY);
                            });

                            layer.on('mousemove', function(e) {
                                // Update tooltip position as mouse moves
                                const mousePos = e.originalEvent || e;
                                updateTooltip(mousePos.clientX, mousePos.clientY);
                            });

                            layer.on('mouseout', function(e) {
                                // Remove tooltip when mouse leaves
                                removeTooltip();
                            });

                            // Add visual feedback on hover
                            layer.on('mouseover', function(e) {
                                const targetLayer = e.target;
                                if (targetLayer.setStyle) {
                                    targetLayer.setStyle({
                                        weight: 3,
                                        opacity: 1,
                                        fillOpacity: 0.6
                                    });
                                }
                            });

                            layer.on('mouseout', function(e) {
                                const targetLayer = e.target;
                                if (targetLayer.setStyle) {
                                    // Reset to original style
                                    targetLayer.setStyle(style);
                                }
                            });
                        }
                    });

                    // Add to vector layer group
                    vectorLayerGroup.addLayer(geoJsonLayer);

                    // Add to map if not already added
                    if (!map.hasLayer(vectorLayerGroup)) {
                        map.addLayer(vectorLayerGroup);
                    }

                    // Zoom to layer bounds if available
                    if (geojson.metadata && geojson.metadata.bounds) {
                        const bounds = geojson.metadata.bounds;
                        map.fitBounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]]);
                    }

                    // Update status
                    const featureCount = geojson.metadata ? geojson.metadata.feature_count : 'unknown';
                    document.getElementById('status').textContent = `Vector layer loaded (${featureCount} features)`;
                    document.getElementById('status').className = 'status';

                    // Hide legend for vector layers
                    document.getElementById('legend-container').style.display = 'none';

            } catch (error) {
                console.error('Error loading vector layer:', error);
                if (error.name === 'AbortError') {
                    document.getElementById('status').textContent = 'Vector layer loading timed out';
                } else {
                    document.getElementById('status').textContent = 'Error loading vector layer';
                }
                document.getElementById('status').className = 'status error';
            }
        }

        // ‚ö° ASYNC OPTIMIZATION FUNCTIONS ‚ö°

        // Concurrent layer processing for better performance
        async function loadMultipleLayersConcurrently(layerNames, maxConcurrent = 3) {
            console.log(`üöÄ Loading ${layerNames.length} layers concurrently (max ${maxConcurrent} parallel)`);

            const results = [];
            const errors = [];

            // Process in batches to avoid overwhelming the server
            for (let i = 0; i < layerNames.length; i += maxConcurrent) {
                const batch = layerNames.slice(i, i + maxConcurrent);

                const batchPromises = batch.map(async (layerName) => {
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 20000); // 20s timeout

                        const response = await fetch(`/api/vector/layer/${encodeURIComponent(layerName)}`, {
                            signal: controller.signal
                        });

                        clearTimeout(timeoutId);

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const data = await response.json();
                        return { layerName, data, success: true };
                    } catch (error) {
                        return { layerName, error: error.message, success: false };
                    }
                });

                const batchResults = await Promise.allSettled(batchPromises);
                batchResults.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        if (result.value.success) {
                            results.push(result.value);
                        } else {
                            errors.push(result.value);
                        }
                    } else {
                        errors.push({ layerName: batch[index], error: result.reason?.message || 'Unknown error', success: false });
                    }
                });

                // Brief pause between batches to be server-friendly
                if (i + maxConcurrent < layerNames.length) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }

            return { results, errors };
        }

        // Background preloading for instant layer access
        async function preloadLayersInBackground() {
            try {
                if (!vectorLayers || vectorLayers.length === 0) return;

                console.log('üì¶ Preloading vector layers in background...');
                const layerNames = vectorLayers.map(layer => layer.display_name);
                const { results, errors } = await loadMultipleLayersConcurrently(layerNames, 2);

                // Cache successful results
                window.layerCache = window.layerCache || new Map();
                results.forEach(({ layerName, data }) => {
                    window.layerCache.set(layerName, data);
                });

                console.log(`‚úÖ Cached ${results.length} layers for instant access`);
                if (errors.length > 0) {
                    console.warn(`‚ö†Ô∏è ${errors.length} layers failed to preload`);
                }

            } catch (error) {
                console.error('‚ùå Background preloading failed:', error);
            }
        }

        // Enhanced layer loading with instant cache access
        async function loadVectorLayerFast(layerName) {
            try {
                // Check cache first for instant loading
                if (window.layerCache && window.layerCache.has(layerName)) {
                    console.log(`‚ö° Loading ${layerName} from cache (instant)`);
                    const geojson = window.layerCache.get(layerName);

                    // Process immediately from cache
                    await processVectorLayerData(geojson, layerName);
                    return;
                }

                // Fallback to regular loading
                console.log(`üì° Loading ${layerName} from server (cache miss)`);
                await loadVectorLayer(layerName);

            } catch (error) {
                console.error(`‚ùå Failed to load layer ${layerName}:`, error);
                document.getElementById('status').textContent = `Failed to load ${layerName}`;
                document.getElementById('status').className = 'status error';
            }
        }

        // Helper to process vector layer data efficiently
        async function processVectorLayerData(geojson, layerName) {
            // Clear existing layers
            vectorLayerGroup.clearLayers();

            const style = geojson.metadata?.style || {
                fillColor: '#3388ff',
                color: '#20B2AA',
                weight: 2,
                fillOpacity: 0.4,
                opacity: 0.8
            };

            // Create optimized GeoJSON layer
            const geoJsonLayer = L.geoJSON(geojson, {
                style: () => style,
                onEachFeature: function(feature, layer) {
                    // Enhanced popup creation
                    if (feature.properties) {
                        // Use the same enhanced content as tooltips for consistency
                        let popupContent = generateTooltipContent(feature, layerName);

                        // Wrap in popup-appropriate styling
                        popupContent = `<div style="max-width: 400px; max-height: 300px; overflow-y: auto;">${popupContent}</div>`;
                        layer.bindPopup(popupContent);
                    }

                    // Optimized hover effects
                    layer.on({
                        mouseover: (e) => {
                            const tooltip = generateTooltipContent(feature, layerName);
                            createTooltip(tooltip, e.originalEvent.pageX, e.originalEvent.pageY);
                            layer.setStyle({ weight: style.weight + 2, fillOpacity: (style.fillOpacity || 0.4) + 0.2 });
                        },
                        mouseout: () => {
                            removeTooltip();
                            layer.setStyle(style);
                        },
                        mousemove: (e) => updateTooltip(e.originalEvent.pageX, e.originalEvent.pageY)
                    });
                }
            });

            vectorLayerGroup.addLayer(geoJsonLayer);

            if (!map.hasLayer(vectorLayerGroup)) {
                map.addLayer(vectorLayerGroup);
            }

            // Zoom to bounds if available
            if (geojson.metadata?.bounds) {
                const [minX, minY, maxX, maxY] = geojson.metadata.bounds;
                map.fitBounds([[minY, minX], [maxY, maxX]]);
            }

            // Update status
            const featureCount = geojson.metadata?.feature_count || 'unknown';
            document.getElementById('status').textContent = `Vector layer loaded (${featureCount} features)`;
            document.getElementById('status').className = 'status';

            document.getElementById('legend-container').style.display = 'none';
        }

        // Create layer select options
        const layerSelect = document.getElementById('layer-select');

        // Add "None" option for no overlay
        const noneOption = document.createElement('option');
        noneOption.value = 'none';
        noneOption.textContent = 'No Overlay';
        noneOption.selected = false; // EUNIS will be selected by default instead
        layerSelect.appendChild(noneOption);

        // Add WMS layers as overlays
        if (wmsLayers.length > 0) {
            const wmsGroup = document.createElement('optgroup');
            wmsGroup.label = 'EMODnet Overlays';
            wmsLayers.forEach((layer, index) => {
                const option = document.createElement('option');
                option.value = 'wms:' + layer.name;
                option.textContent = layer.title || layer.name;
                wmsGroup.appendChild(option);
            });
            layerSelect.appendChild(wmsGroup);
        }

        // Create HELCOM layer select options
        const helcomSelect = document.getElementById('helcom-select');

        // Add "None" option for no HELCOM overlay
        const helcomNoneOption = document.createElement('option');
        helcomNoneOption.value = 'none';
        helcomNoneOption.textContent = 'No HELCOM Overlay';
        helcomNoneOption.selected = true; // Default selection
        helcomSelect.appendChild(helcomNoneOption);

        // Add HELCOM layers
        if (helcomLayers.length > 0) {
            const helcomGroup = document.createElement('optgroup');
            helcomGroup.label = 'HELCOM Pressures';
            helcomLayers.forEach((layer, index) => {
                const option = document.createElement('option');
                option.value = 'helcom:' + layer.name;
                option.textContent = layer.title || layer.name;
                helcomGroup.appendChild(option);
            });
            helcomSelect.appendChild(helcomGroup);
        }

        // Vector layers are now loaded by default, not shown in dropdown

        // Layer select change handler (now only handles WMS overlays)
        layerSelect.onchange = function(e) {
            const selectedValue = e.target.value;
            if (selectedValue === 'none') {
                // Remove WMS overlay
                if (wmsLayer) {
                    map.removeLayer(wmsLayer);
                    wmsLayer = null;
                }
                // Clear legend
                document.getElementById('legend').innerHTML = '';
                currentLayerType = 'vector'; // Back to vector only
            } else if (selectedValue.startsWith('wms:')) {
                const layerName = selectedValue.substring(4);
                selectWMSLayerAsOverlay(layerName);
            }
        };

        // HELCOM select change handler
        helcomSelect.onchange = function(e) {
            const selectedValue = e.target.value;
            if (selectedValue === 'none') {
                // Remove HELCOM overlay
                if (helcomLayer) {
                    map.removeLayer(helcomLayer);
                    helcomLayer = null;
                }
                currentLayerType = 'vector'; // Back to vector only
            } else if (selectedValue.startsWith('helcom:')) {
                const layerName = selectedValue.substring(7);
                selectHELCOMLayerAsOverlay(layerName);
            }
        };

        // Function to select WMS layer as base layer (original behavior)
        function selectWMSLayer(layerName) {
            currentLayer = layerName;
            currentLayerType = 'wms';

            // Remove any existing tooltip
            removeTooltip();

            // Clear vector layers
            vectorLayerGroup.clearLayers();
            if (map.hasLayer(vectorLayerGroup)) {
                map.removeLayer(vectorLayerGroup);
            }

            // Clear existing WMS layer
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // Add WMS layer
            wmsLayer = L.tileLayer.wms('https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_view/wms', {
                layers: layerName,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: currentOpacity
            });

            wmsLayer.addTo(map);

            // Update legend
            updateLegend(layerName);
        }

        // Function to select WMS layer as overlay (new behavior for dropdown)
        function selectWMSLayerAsOverlay(layerName) {
            currentLayer = layerName;
            currentLayerType = 'wms-overlay';

            // Clear existing WMS layer
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // Add WMS layer as overlay on top of vector layers
            wmsLayer = L.tileLayer.wms('https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_view/wms', {
                layers: layerName,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: currentOpacity
            });

            wmsLayer.addTo(map);

            // Update legend
            updateLegend(layerName);
        }

        // Function to select HELCOM layer as overlay
        function selectHELCOMLayerAsOverlay(layerName) {
            currentLayer = layerName;
            currentLayerType = 'helcom-overlay';

            // Clear existing HELCOM layer
            if (helcomLayer) {
                map.removeLayer(helcomLayer);
            }

            // Add HELCOM layer as overlay on top of vector layers
            helcomLayer = L.tileLayer.wms('{{ HELCOM_WMS_BASE_URL }}', {
                layers: layerName,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: currentOpacity
            });

            helcomLayer.addTo(map);

            // Clear legend since HELCOM might not have standard legends
            document.getElementById('legend').innerHTML = '';
        }

        // Function to select vector layer
        function selectVectorLayer(layerName) {
            currentLayer = layerName;
            currentLayerType = 'vector';

            // Remove any existing tooltip
            removeTooltip();

            // Remove WMS layer
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
                wmsLayer = null;
            }

            // Load vector layer
            loadVectorLayer(layerName);
        }

        // Function to select vector layer as base layer
        function selectVectorLayerAsBase(layerName) {
            selectVectorLayer(layerName);
        }

        // Opacity control
        const opacitySlider = document.getElementById('opacity');
        const opacityValue = document.getElementById('opacity-value');

        opacitySlider.oninput = function() {
            currentOpacity = this.value / 100;
            opacityValue.textContent = this.value + '%';

            if ((currentLayerType === 'wms' || currentLayerType === 'wms-overlay') && wmsLayer) {
                wmsLayer.setOpacity(currentOpacity);
            } else if (currentLayerType === 'helcom-overlay' && helcomLayer) {
                helcomLayer.setOpacity(currentOpacity);
            } else if (currentLayerType === 'vector' && map.hasLayer(vectorLayerGroup)) {
                // Update opacity for vector layers
                vectorLayerGroup.eachLayer(function(layer) {
                    if (layer.setStyle) {
                        const currentStyle = layer.options.style || {};
                        layer.setStyle({
                            ...currentStyle,
                            opacity: currentOpacity,
                            fillOpacity: currentOpacity * 0.6  // Slightly more transparent fill
                        });
                    }
                });
            }
        };

        // Base map switcher
        document.getElementById('basemap').onchange = function(e) {
            map.removeLayer(currentBaseMap);
            currentBaseMap = baseMaps[e.target.value];
            currentBaseMap.addTo(map);

            // Move WMS layer to top
            if (wmsLayer) {
                wmsLayer.bringToFront();
            }
        };

        // OLD INITIALIZATION - DISABLED
        // This old code loads WMS layer as base (removes vectors)
        // New initialization at line 2548 handles both BBT + WMS overlay together
        console.log('‚è≠Ô∏è Skipping old WMS-only initialization (using new BBT + WMS overlay method)');

        // // Load initial layer
        // // Load EUSeaMap 2023 EUNIS as the default European marine habitat layer
        // console.log('üåä Loading default layer: EUSeaMap 2023 European Biological Zones');
        // document.getElementById('status').textContent = 'Loading EUSeaMap 2023 Biological Zones...';
        // document.getElementById('status').className = 'status loading';

        // // Load the EUSeaMap 2023 European Biological Zones layer (better performance)
        // try {
        //     selectWMSLayer('eusm2023_bio_full');

        //     // Update layer selection dropdown to show the selected layer
        //     const layerSelect = document.getElementById('layer-select');
        //     if (layerSelect) {
        //         layerSelect.value = `wms:eusm2023_bio_full`;
        //     }
        // } catch (error) {
        //     console.error('Failed to load default layer:', error);
        //     document.getElementById('status').textContent = 'Map ready (WMS service unavailable)';
        //     document.getElementById('status').className = 'status';
        // }

        // // Set up fallback timer for slow WMS loading
        // setTimeout(() => {
        //     const statusEl = document.getElementById('status');
        //     if (statusEl.textContent.includes('Loading')) {
        //         statusEl.textContent = 'Map ready (WMS loading in background)';
        //         statusEl.className = 'status';
        //     }
        // }, 5000); // 5 second timeout

        // Also load vector layers in the background for BBT navigation
        if (vectorSupport && vectorLayers.length > 0) {
            console.log('üöÄ Starting optimized async layer preloading...');
            setTimeout(() => {
                // Use the new concurrent preloading function
                preloadLayersInBackground().then(() => {
                    console.log('‚úÖ Background preloading complete - layers ready for instant access!');
                }).catch(error => {
                    console.error('‚ùå Background preloading failed:', error);
                    // Fallback to old method
                    console.log('üîÑ Falling back to sequential loading...');
                    vectorLayers.forEach(layer => {
                        setTimeout(() => loadVectorLayer(layer.display_name), Math.random() * 1000);
                    });
                });
            }, 1500); // Start preloading slightly earlier
        }

        // Function to load European EuSeaMap layers with fallback
        function loadEuropeanEuSeaMapLayerWithFallback(layerName, opacity) {
            console.log('üì° Attempting to load European EuSeaMap layer with fallback:', layerName);

            // First try the European endpoint
            loadEuropeanEuSeaMapLayer(layerName, opacity);

            // Set up fallback to standard endpoint after timeout
            setTimeout(() => {
                const statusEl = document.getElementById('status');
                if (statusEl.textContent.includes('Loading')) {
                    console.log('‚ö†Ô∏è European endpoint slow, trying fallback layer...');
                    loadFallbackWMSLayer();
                }
            }, 8000); // 8 second timeout before fallback
        }

        // Function to load a fallback WMS layer from standard endpoint
        function loadFallbackWMSLayer() {
            console.log('üì° Loading fallback WMS layer from standard endpoint');

            // Remove existing WMS layer if present
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // Use a known working layer from standard endpoint
            const standardWmsUrl = 'https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_view/wms';
            const fallbackLayer = 'eusm2023_bio_full'; // European Biological Zones (working alternative)

            wmsLayer = L.tileLayer.wms(standardWmsUrl, {
                layers: fallbackLayer,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: currentOpacity,
                attribution: 'MARBEFES BBT Database | EMODnet Seabed Habitats | EUSeaMap 2023 Biological Zones',
                tiled: true,
                timeout: 10000,
                errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='
            });

            // Add error handling for fallback layer
            wmsLayer.on('tileerror', function(e) {
                console.warn('Fallback WMS tile failed:', e.tile.src);
                document.getElementById('status').textContent = 'Map ready (WMS service unavailable)';
                document.getElementById('status').className = 'status';
            });

            wmsLayer.on('tileload', function() {
                document.getElementById('status').textContent = 'EUSeaMap 2023 Biological Zones loaded (fallback)';
                document.getElementById('status').className = 'status success';
            });

            wmsLayer.addTo(map);

            // Set up click events for GetFeatureInfo
            setupGetFeatureInfo(fallbackLayer);

            // Update legend for fallback layer
            updateLegend(fallbackLayer);

            // Update dropdown to reflect actual loaded layer
            const layerSelect = document.getElementById('layer-select');
            if (layerSelect) {
                layerSelect.value = `wms:${fallbackLayer}`;
            }
        }

        // Function to retry loading default layer manually
        function retryDefaultLayer() {
            console.log('üîÑ Manual retry of default layer requested');
            document.getElementById('status').textContent = 'Retrying default layer...';
            document.getElementById('status').className = 'status loading';

            // Remove any existing layer
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // Try loading default layer again
            selectWMSLayer(currentLayer);

            // Update dropdown
            const layerSelect = document.getElementById('layer-select');
            if (layerSelect) {
                layerSelect.value = `wms:${currentLayer}`;
            }
        }

        // Function to load European EuSeaMap layers from the emodnet_open endpoint
        function loadEuropeanEuSeaMapLayer(layerName, opacity) {
            console.log('üì° Loading European EuSeaMap layer:', layerName);

            // Remove existing WMS layer if present
            if (wmsLayer) {
                map.removeLayer(wmsLayer);
            }

            // European EuSeaMap layers are in the emodnet_open endpoint
            const europeanWmsUrl = 'https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_open/wms';

            // Add new WMS layer from European endpoint with error handling
            wmsLayer = L.tileLayer.wms(europeanWmsUrl, {
                layers: layerName,
                format: 'image/png',
                transparent: true,
                version: '1.1.0',
                opacity: opacity,
                attribution: 'MARBEFES BBT Database | EMODnet Seabed Habitats | EUSeaMap 2023',
                tiled: true,
                timeout: 10000, // 10 second timeout for tile requests
                errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==' // Transparent 1x1 pixel
            });

            // Add error handling for tile loading
            wmsLayer.on('tileerror', function(e) {
                console.warn('WMS tile failed to load:', e.tile.src);
            });

            wmsLayer.on('tileloadstart', function() {
                console.log('WMS tile loading started...');
            });

            wmsLayer.on('tileload', function() {
                document.getElementById('status').textContent = 'EUSeaMap 2023 EUNIS loaded';
                document.getElementById('status').className = 'status success';
            });

            wmsLayer.addTo(map);

            // Set up click events for GetFeatureInfo
            setupGetFeatureInfo(layerName);

            // Update legend - try from European endpoint first
            updateEuropeanLegend(layerName);

            // Set appropriate zoom for European waters
            map.setView([54.0, 10.0], 4);
        }

        // Function to update legend for European layers
        function updateEuropeanLegend(layerName) {
            const europeanWmsUrl = 'https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_open/wms';
            const legendUrl = `${europeanWmsUrl}?service=WMS&version=1.1.0&request=GetLegendGraphic&layer=${layerName}&format=image/png`;
            const legendImg = document.getElementById('legend-image');
            const legendContainer = document.getElementById('legend-container');

            if (legendImg && legendContainer) {
                legendImg.src = legendUrl;
                legendImg.onload = () => {
                    legendContainer.style.display = 'block';
                };
                legendImg.onerror = () => {
                    console.log('European legend not available, trying standard legend...');
                    updateLegend(layerName); // Fallback to standard legend
                };
            }
        }

        // Add scale control
        L.control.scale().addTo(map);

        // Add zoom control with custom position
        map.zoomControl.setPosition('topright');

        // Remove tooltips when clicking on empty map areas
        map.on('click', function(e) {
            removeTooltip();
        });

        // ===== AUTOMATIC ZOOM-BASED LAYER SWITCHING =====
        // Ensures optimal EUSeaMap simplification level is visible at all zoom levels
        let autoSwitchEnabled = true;
        let lastAutoSwitchedZoom = -1;

        function getOptimalEUSeaMapLayer(zoom) {
            // Return best layer name based on zoom level
            // Includes fallback to group layer if specific simplification unavailable
            if (zoom <= 6) {
                return ['eusm2023_bio_800', 'eusm2023_bio_group', 'eusm2023_bio_full'];
            } else if (zoom <= 8) {
                return ['eusm2023_bio_400', 'eusm2023_bio_group', 'eusm2023_bio_full'];
            } else if (zoom <= 12) {
                return ['eusm2023_bio_200', 'eusm2023_bio_group', 'eusm2023_bio_full'];
            } else {
                return ['eusm2023_bio_full', 'eusm2023_bio_group'];
            }
        }

        function switchEUSeaMapLayerByZoom() {
            if (!autoSwitchEnabled) return;
            if (!wmsLayer || !map.hasLayer(wmsLayer)) return;

            const currentZoom = map.getZoom();
            const zoomThreshold = 1; // Only switch if zoom changes by more than this

            if (Math.abs(currentZoom - lastAutoSwitchedZoom) < zoomThreshold) {
                return; // Don't switch for minor zoom changes
            }

            const optimalLayers = getOptimalEUSeaMapLayer(currentZoom);
            const currentLayerName = wmsLayer.options.layers;

            // Check if current layer is still optimal
            if (optimalLayers.includes(currentLayerName)) {
                return; // Current layer is fine
            }

            // Switch to optimal layer
            console.log(`üîÑ Zoom changed to ${currentZoom}, switching to optimal EUSeaMap layer...`);
            const newLayer = optimalLayers[0]; // Try first option

            selectWMSLayerAsOverlay(newLayer);

            // Update dropdown
            const layerSelect = document.getElementById('layer-select');
            if (layerSelect) {
                layerSelect.value = 'wms:' + newLayer;
            }

            lastAutoSwitchedZoom = currentZoom;
            console.log(`‚úÖ Switched to ${newLayer} for zoom ${currentZoom}`);
        }

        // Attach zoom event listener with debouncing
        let zoomSwitchTimeout;
        map.on('zoomend', function() {
            clearTimeout(zoomSwitchTimeout);
            zoomSwitchTimeout = setTimeout(switchEUSeaMapLayerByZoom, 300);
        });

        console.log('üéØ Automatic zoom-based EUSeaMap layer switching enabled');

        // Optimized Direct BBT Area Zoom Function (no zoom bounce)
        function zoomToBBTArea(areaName) {
            console.log('üéØ Zooming directly to BBT area:', areaName);

            // Update button states immediately
            document.querySelectorAll('.bbt-nav-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === areaName) {
                    btn.classList.add('active');
                }
            });

            // Update status
            document.getElementById('status').textContent = `Loading ${areaName}...`;
            document.getElementById('status').className = 'status loading';

            // Set layer selection state
            currentLayer = 'Bbts - Broad Belt Transects';
            currentLayerType = 'vector';

            console.log('üì° Loading BBT data for direct zoom...');

            // Load the BBT vector layer data
            fetch(`/api/vector/layer/${encodeURIComponent('Bbts - Broad Belt Transects')}`)
                .then(response => {
                    console.log('üì• BBT layer API response:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(geojson => {
                    console.log('‚úÖ BBT data loaded, features:', geojson.features ? geojson.features.length : 0);

                    // Store the data for future use
                    bbtFeatureData = geojson;

                    // Find the specific feature
                    const feature = geojson.features.find(f => f.properties.Name === areaName);

                    if (feature) {
                        console.log('‚úÖ Found specific BBT feature, zooming directly...');

                        // Clear any existing layers first
                        if (typeof vectorLayerGroup !== 'undefined') {
                            vectorLayerGroup.clearLayers();
                        }

                        // Load the complete layer WITHOUT auto-zoom
                        loadVectorLayerWithoutAutoZoom('Bbts - Broad Belt Transects', geojson);

                        // Then zoom directly to the specific feature with optimized timing
                        setTimeout(() => {
                            zoomDirectlyToBBTFeature(feature, areaName);
                        }, 100); // Reduced delay for faster UX
                    } else {
                        console.log('‚ö†Ô∏è Specific feature not found, loading full layer...');
                        // Fallback to fast cached loading
                        loadVectorLayerFast('Bbts - Broad Belt Transects');
                    }
                })
                .catch(error => {
                    console.error('‚ùå Failed to load BBT data:', error);
                    document.getElementById('status').textContent = `Failed to load ${areaName}`;
                    document.getElementById('status').className = 'status error';

                    // Fallback zoom
                    console.log('üìç Using fallback zoom');
                    zoomToGeneralBBTArea(areaName);
                });
        }

        // Function to zoom to specific feature once layer is loaded
        function zoomToSpecificBBTFeature(areaName) {
            console.log('üîç Looking for BBT feature:', areaName);

            // If we don't have the data yet, load it
            if (!bbtFeatureData) {
                console.log('üì° Loading BBT data to find feature...');
                loadBBTFeatures().then(() => {
                    zoomToSpecificBBTFeature(areaName);
                }).catch((error) => {
                    console.log('‚ö†Ô∏è Could not load BBT data, using general zoom');
                    // Fallback: Just zoom to overall BBT bounds
                    zoomToGeneralBBTArea(areaName);
                });
                return;
            }

            // Find the matching feature
            const feature = bbtFeatureData.features.find(f => f.properties.Name === areaName);
            if (feature) {
                console.log('‚úÖ Found feature, zooming to specific area...');
                zoomToBBTFeature(feature, null);
                document.getElementById('status').textContent = `Zoomed to ${areaName}`;
                document.getElementById('status').className = 'status success';
            } else {
                console.log('‚ö†Ô∏è Feature not found, using general zoom');
                zoomToGeneralBBTArea(areaName);
            }
        }

        // Fallback function for general BBT area zoom
        function zoomToGeneralBBTArea(areaName) {
            console.log('üìç Using general BBT area zoom for:', areaName);

            // Use vector layer bounds if available
            if (vectorLayerGroup && vectorLayerGroup.getLayers().length > 0) {
                const bounds = vectorLayerGroup.getBounds();
                if (bounds.isValid()) {
                    map.fitBounds(bounds, {padding: [20, 20]});
                    document.getElementById('status').textContent = `Showing ${areaName} in BBT layer`;
                    document.getElementById('status').className = 'status success';
                    return;
                }
            }

            // Final fallback: zoom to general European marine area
            map.setView([55.0, 10.0], 4);
            document.getElementById('status').textContent = `Showing general area for ${areaName}`;
            document.getElementById('status').className = 'status warning';
        }

        // Optimized helper function: Direct zoom to BBT feature without bounce
        function zoomDirectlyToBBTFeature(feature, areaName) {
            console.log('üéØ Zooming directly to BBT feature:', areaName);

            // Calculate bounds for the feature
            let bounds = L.latLngBounds();

            if (feature.geometry.type === 'Polygon') {
                feature.geometry.coordinates[0].forEach(coord => {
                    bounds.extend([coord[1], coord[0]]);
                });
            } else if (feature.geometry.type === 'MultiPolygon') {
                feature.geometry.coordinates.forEach(polygon => {
                    polygon[0].forEach(coord => {
                        bounds.extend([coord[1], coord[0]]);
                    });
                });
            }

            // Zoom to the feature bounds with optimal padding
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [30, 30] });

                // Update status
                document.getElementById('status').textContent = `Zoomed to ${areaName}`;
                document.getElementById('status').className = 'status success';

                console.log('‚úÖ Direct zoom completed for:', areaName);
            } else {
                console.log('‚ö†Ô∏è Invalid bounds, using fallback zoom');
                zoomToGeneralBBTArea(areaName);
            }
        }

        // Helper function: Load vector layer without automatic zoom
        function loadVectorLayerWithoutAutoZoom(layerName, geojson) {
            console.log('üìç Loading vector layer without auto-zoom:', layerName);

            // Remove existing vector layers
            if (vectorLayerGroup) {
                vectorLayerGroup.clearLayers();
            }

            // KEEP WMS/HELCOM overlays - don't remove them during BBT navigation
            // Users want to see both BBT shapes and EUSeaMap habitat data together
            console.log('‚úÖ Preserving WMS overlay during BBT zoom');

            // Create GeoJSON layer with styling and interactivity
            const geoJsonLayer = L.geoJSON(geojson, {
                style: function(feature) {
                    const style = geojson.metadata && geojson.metadata.style ?
                                geojson.metadata.style :
                                {
                                    fillColor: '#20B2AA',
                                    color: '#008B8B',
                                    weight: 2,
                                    fillOpacity: 0.4,
                                    opacity: 0.8
                                };
                    return {
                        ...style,
                        opacity: currentOpacity,
                        fillOpacity: currentOpacity * 0.6
                    };
                },
                onEachFeature: function(feature, layer) {
                    // Add hover events for tooltip
                    layer.on('mouseover', function(e) {
                        showTooltip(e, feature);
                    });
                    layer.on('mouseout', function() {
                        removeTooltip();
                    });
                    layer.on('mousemove', function(e) {
                        updateTooltipPosition(e);
                    });
                }
            });

            // Add to vector layer group
            if (!vectorLayerGroup) {
                vectorLayerGroup = L.layerGroup();
            }
            vectorLayerGroup.addLayer(geoJsonLayer);
            vectorLayerGroup.addTo(map);

            // Update layer selection UI
            const vectorSelect = document.getElementById('vector-select');
            if (vectorSelect) {
                vectorSelect.value = layerName;
            }

            // Hide legend for vector layers
            document.getElementById('legend-container').style.display = 'none';

            console.log('‚úÖ Vector layer loaded without auto-zoom');
        }

        // Helper functions for tooltips
        function showTooltip(e, feature) {
            const tooltipContent = generateTooltipContent(feature, currentLayer);
            const mousePos = e.originalEvent || e;
            createTooltip(tooltipContent, mousePos.clientX, mousePos.clientY);
        }

        function updateTooltipPosition(e) {
            const mousePos = e.originalEvent || e;
            updateTooltip(mousePos.clientX, mousePos.clientY);
        }

        // Enhanced BBT Navigation Initialization (background loading)
        async function initializeBBTNavigation() {
            console.log('üöÄ Background loading BBT navigation data...');
            try {
                await loadBBTFeatures(); // Load data in background for future use
                console.log('‚úÖ BBT navigation initialized successfully');
            } catch (error) {
                // Check if it's a 503 error (vector support disabled)
                if (error.message.includes('503')) {
                    console.warn('‚ö†Ô∏è Vector support disabled - BBT navigation unavailable');
                    showBBTLoadingError('BBT features unavailable (vector support disabled)');
                } else {
                    console.error('‚ùå Failed to initialize BBT navigation:', error);
                    showBBTLoadingError('Failed to load BBT features');
                }
            }
        }

        // Background initialization (non-blocking)
        setTimeout(initializeBBTNavigation, 2000);

        // ===== PYDECK / DECK.GL INTEGRATION =====

        let deckInstance = null;
        let pydeckEnabled = false;
        let sampleData = [];

        // Generate sample oceanographic data points
        function generateOceanData() {
            const data = [];
            // Baltic Sea bounds
            const latMin = 53.0, latMax = 66.0;
            const lonMin = 9.0, lonMax = 31.0;

            for (let i = 0; i < 5000; i++) {
                const lat = latMin + Math.random() * (latMax - latMin);
                const lon = lonMin + Math.random() * (lonMax - lonMin);
                data.push({
                    position: [lon, lat],
                    depth: Math.random() * 300 + 10, // 10-310m depth
                    temperature: Math.random() * 15 + 5, // 5-20¬∞C
                    salinity: Math.random() * 10 + 30, // 30-40 PSU
                    chlorophyll: Math.random() * 50 + 0.5, // 0.5-50.5 ¬µg/L
                    biomass: Math.random() * 1000 + 10, // 10-1010 g/m¬≤
                    species_count: Math.floor(Math.random() * 50) + 1
                });
            }
            return data;
        }

        // Color schemes
        const colorSchemes = {
            viridis: [[68, 1, 84], [59, 82, 139], [33, 144, 141], [94, 201, 98], [253, 231, 37]],
            plasma: [[13, 8, 135], [126, 3, 168], [203, 70, 121], [249, 142, 8], [240, 249, 33]],
            ocean: [[0, 119, 190], [0, 180, 216], [144, 224, 239], [173, 232, 244], [240, 249, 232]],
            thermal: [[0, 0, 0], [128, 0, 0], [255, 128, 0], [255, 255, 0], [255, 255, 255]],
            turbo: [[48, 18, 59], [33, 144, 141], [94, 201, 98], [253, 231, 37], [122, 4, 3]]
        };

        // Initialize PyDeck
        function initializePyDeck() {
            if (!window.deck) {
                console.warn('Deck.gl not loaded');
                return;
            }

            sampleData = generateOceanData();

            const mapBounds = map.getBounds();
            const center = map.getCenter();

            deckInstance = new deck.Deck({
                container: 'pydeck-overlay',
                initialViewState: {
                    longitude: center.lng,
                    latitude: center.lat,
                    zoom: map.getZoom() - 1,
                    pitch: 0,
                    bearing: 0
                },
                controller: false, // Let Leaflet handle interaction
                layers: []
            });

            // Sync with Leaflet map movements
            map.on('moveend', syncDeckWithLeaflet);
            map.on('zoomend', syncDeckWithLeaflet);

            console.log('PyDeck initialized with', sampleData.length, 'data points');
        }

        // Sync Deck.gl view with Leaflet map
        function syncDeckWithLeaflet() {
            if (!deckInstance) return;

            const center = map.getCenter();
            const zoom = map.getZoom();
            const viewMode = document.getElementById('view-mode').value;

            let pitch = 0, bearing = 0;

            switch(viewMode) {
                case '3d': pitch = 45; break;
                case 'bird': pitch = 60; break;
                case 'first-person': pitch = 80; bearing = 45; break;
            }

            deckInstance.setProps({
                viewState: {
                    longitude: center.lng,
                    latitude: center.lat,
                    zoom: zoom - 1,
                    pitch: pitch,
                    bearing: bearing
                }
            });
        }

        // Create PyDeck layer based on type
        function createPyDeckLayer(layerType, colorScheme) {
            if (!sampleData.length) return null;

            const colors = colorSchemes[colorScheme] || colorSchemes.viridis;
            const elevationScale = parseInt(document.getElementById('elevation-scale').value);
            const radiusScale = parseInt(document.getElementById('radius-scale').value);

            switch(layerType) {
                case 'hexagon':
                    return new deck.HexagonLayer({
                        id: 'hexagon-layer',
                        data: sampleData,
                        pickable: true,
                        extruded: true,
                        radius: radiusScale,
                        elevationScale: elevationScale / 100,
                        elevationRange: [0, 1000],
                        colorRange: colors,
                        getPosition: d => d.position,
                        getElevationWeight: d => d.biomass,
                        getColorWeight: d => d.depth
                    });

                case 'heatmap':
                    return new deck.HeatmapLayer({
                        id: 'heatmap-layer',
                        data: sampleData,
                        getPosition: d => d.position,
                        getWeight: d => d.temperature,
                        radiusPixels: 60,
                        colorRange: colors
                    });

                case 'grid':
                    return new deck.GridLayer({
                        id: 'grid-layer',
                        data: sampleData,
                        pickable: true,
                        extruded: true,
                        cellSize: radiusScale * 2,
                        elevationScale: elevationScale / 50,
                        colorRange: colors,
                        getPosition: d => d.position,
                        getElevationWeight: d => d.chlorophyll,
                        getColorWeight: d => d.salinity
                    });

                case 'contour':
                    return new deck.ContourLayer({
                        id: 'contour-layer',
                        data: sampleData,
                        cellSize: radiusScale * 3,
                        getPosition: d => d.position,
                        getWeight: d => d.depth,
                        contours: [
                            {threshold: 50, color: colors[0]},
                            {threshold: 100, color: colors[1]},
                            {threshold: 150, color: colors[2]},
                            {threshold: 200, color: colors[3]},
                            {threshold: 250, color: colors[4]}
                        ]
                    });

                case 'column':
                    return new deck.ColumnLayer({
                        id: 'column-layer',
                        data: sampleData.slice(0, 1000), // Limit for performance
                        diskResolution: 12,
                        radius: radiusScale / 2,
                        extruded: true,
                        pickable: true,
                        elevationScale: elevationScale,
                        getPosition: d => d.position,
                        getFillColor: d => {
                            const temp = d.temperature;
                            const colorIndex = Math.floor((temp / 20) * (colors.length - 1));
                            return colors[Math.min(colorIndex, colors.length - 1)];
                        },
                        getElevation: d => d.biomass
                    });

                default:
                    return null;
            }
        }

        // Update PyDeck visualization
        function updatePyDeckVisualization() {
            if (!pydeckEnabled || !deckInstance) return;

            const layerType = document.getElementById('pydeck-layer').value;
            const colorScheme = document.getElementById('color-scheme').value;

            let layers = [];
            if (layerType !== 'none') {
                const layer = createPyDeckLayer(layerType, colorScheme);
                if (layer) layers.push(layer);
            }

            deckInstance.setProps({ layers });
            syncDeckWithLeaflet();
        }

        // Event handlers for PyDeck controls
        document.getElementById('enable-3d').onchange = function(e) {
            pydeckEnabled = e.target.checked;
            const overlay = document.getElementById('pydeck-overlay');

            if (pydeckEnabled) {
                if (!deckInstance) initializePyDeck();
                overlay.style.pointerEvents = 'auto';
                updatePyDeckVisualization();
                document.getElementById('status').textContent = 'PyDeck 3D visualization enabled';
            } else {
                overlay.style.pointerEvents = 'none';
                if (deckInstance) deckInstance.setProps({ layers: [] });
                document.getElementById('status').textContent = 'PyDeck 3D visualization disabled';
            }
        };

        document.getElementById('pydeck-layer').onchange = updatePyDeckVisualization;
        document.getElementById('color-scheme').onchange = updatePyDeckVisualization;
        document.getElementById('view-mode').onchange = syncDeckWithLeaflet;

        document.getElementById('elevation-scale').oninput = function() {
            document.getElementById('elevation-value').textContent = this.value + 'x';
            if (pydeckEnabled) updatePyDeckVisualization();
        };

        document.getElementById('radius-scale').oninput = function() {
            document.getElementById('radius-value').textContent = this.value + 'm';
            if (pydeckEnabled) updatePyDeckVisualization();
        };

        // Theme switching functionality
        function changeTheme(themeName) {
            console.log('üé® Changing theme to:', themeName);
            document.body.setAttribute('data-theme', themeName);

            // Save theme preference to localStorage
            localStorage.setItem('selected-theme', themeName);

            // Update status to show theme changed
            const statusEl = document.getElementById('status');
            const currentStatus = statusEl.textContent;
            statusEl.textContent = `Theme changed to ${themeName.charAt(0).toUpperCase() + themeName.slice(1)}`;
            statusEl.className = 'status';

            // Restore original status after 2 seconds
            setTimeout(() => {
                statusEl.textContent = currentStatus;
            }, 2000);
        }

        // Initialize theme from localStorage or default to ocean
        function initializeTheme() {
            const savedTheme = localStorage.getItem('selected-theme') || 'ocean';
            document.body.setAttribute('data-theme', savedTheme);

            // Update the select element to match
            const themeSelect = document.getElementById('theme');
            if (themeSelect) {
                themeSelect.value = savedTheme;
            }

            console.log('üé® Theme initialized:', savedTheme);
        }

        // Theme selector change handler
        document.getElementById('theme').onchange = function(e) {
            changeTheme(e.target.value);
        };

        // Initialize theme on page load
        initializeTheme();

        // Auto-load BBT vector layers and EUSeaMap 400m overlay on page startup
        function initializeVectorLayers() {
            console.log('üöÄ Auto-loading BBT vector layers on startup...');

            if (vectorLayers && vectorLayers.length > 0) {
                // Load the main BBT layer by default
                const bbtLayer = vectorLayers.find(layer =>
                    layer.display_name.includes('Broad Belt Transects') ||
                    layer.display_name.includes('BBT')
                );

                if (bbtLayer) {
                    console.log('üìç Loading primary BBT layer:', bbtLayer.display_name);
                    loadVectorLayerFast(bbtLayer.display_name);
                } else if (vectorLayers.length > 0) {
                    // Fallback to first available layer
                    console.log('üìç Loading first available vector layer:', vectorLayers[0].display_name);
                    loadVectorLayerFast(vectorLayers[0].display_name);
                }
            } else {
                console.log('‚ö†Ô∏è No vector layers available for auto-loading');
            }

            // Auto-load EUNIS 2019 full resolution as overlay (only when zoomed in to BBT coverage)
            setTimeout(() => {
                const defaultWMSLayer = 'eusm_2023_eunis2019_full';

                // Check if we're zoomed in enough for BBT coverage (zoom level 8 or higher)
                const currentZoom = map.getZoom();
                if (currentZoom >= 8) {
                    console.log('üåä Auto-loading EUNIS 2019 full resolution overlay (zoom level sufficient)...');
                    selectWMSLayerAsOverlay(defaultWMSLayer);

                    // Update dropdown selection to reflect the loaded layer
                    const layerSelect = document.getElementById('layer-select');
                    if (layerSelect) {
                        layerSelect.value = 'wms:' + defaultWMSLayer;
                    }

                    console.log('‚úÖ Default layers loaded: BBT vectors + EUNIS 2019 full');
                } else {
                    console.log('‚ÑπÔ∏è  EUNIS 2019 layer will load when you zoom into BBT coverage (zoom >= 8)');
                }
            }, 1500);
        }

        // Initialize vector layers after a brief delay to ensure DOM is ready
        setTimeout(initializeVectorLayers, 1000);

        // Auto-load EUNIS 2019 layer when user zooms into BBT coverage
        let eunis2019Loaded = false;
        map.on('zoomend', function() {
            const currentZoom = map.getZoom();
            const defaultWMSLayer = 'eusm_2023_eunis2019_full';

            // Load EUNIS 2019 when zoomed in (zoom >= 8) and not already loaded
            if (currentZoom >= 8 && !eunis2019Loaded) {
                console.log('üåä Auto-loading EUNIS 2019 full resolution (zoomed into BBT coverage)...');
                selectWMSLayerAsOverlay(defaultWMSLayer);

                // Update dropdown selection
                const layerSelect = document.getElementById('layer-select');
                if (layerSelect) {
                    layerSelect.value = 'wms:' + defaultWMSLayer;
                }

                eunis2019Loaded = true;
                console.log('‚úÖ EUNIS 2019 layer loaded automatically');
            }
        });

    </script>
</body>
</html>