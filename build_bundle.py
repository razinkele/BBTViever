#!/usr/bin/env python3
"""
Enhanced JavaScript bundler for MARBEFES BBT Database
- Concatenates all JavaScript files in correct dependency order
- Adds version-based cache-busting
- Generates minified bundle with terser
- Creates bundle manifest for Flask templates
"""

import os
import sys
import json
import hashlib
import subprocess
from pathlib import Path
from datetime import datetime

# Add src to path to import version
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "src"))
from emodnet_viewer.__version__ import __version__

# Source files in dependency order
JS_FILES = [
    "static/js/utils/debug.js",
    "static/js/data/bbt-regions.js",
    "static/js/data/marbefes-datasets.js",
    "static/js/config.js",
    "static/js/map-init.js",
    "static/js/layer-manager.js",
    "static/js/bbt-tool.js",
    "static/js/ui-handlers.js",
    "static/js/app.js",
]


def generate_content_hash(content):
    """Generate SHA256 hash of content for cache-busting"""
    return hashlib.sha256(content.encode('utf-8')).hexdigest()[:8]


def check_terser_available():
    """Check if terser is available via npx"""
    try:
        result = subprocess.run(
            ["npx", "terser", "--version"],
            capture_output=True,
            text=True,
            timeout=5
        )
        return result.returncode == 0
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return False


def build_bundle(use_version_hash=True):
    """
    Build JavaScript bundle by concatenating source files

    Args:
        use_version_hash: If True, includes content hash in filename for cache-busting
    """
    print("üì¶ Building JavaScript bundle...")
    print(f"   Version: {__version__}")

    # Create dist directory
    dist_dir = Path("static/dist")
    dist_dir.mkdir(parents=True, exist_ok=True)

    # Banner with version info
    banner = f"""/**
 * MARBEFES BBT Database - JavaScript Bundle v{__version__}
 * Generated: {datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")}
 *
 * DO NOT EDIT THIS FILE DIRECTLY
 * Edit source files in static/js/ and rebuild with: python build_bundle.py
 *
 * Modules included:
 * - debug.js (Conditional debug logging)
 * - bbt-regions.js (BBT region data)
 * - marbefes-datasets.js (MARBEFES datasets)
 * - config.js (Application configuration)
 * - map-init.js (Map initialization)
 * - layer-manager.js (Layer management)
 * - bbt-tool.js (BBT navigation tool)
 * - ui-handlers.js (UI event handlers)
 * - app.js (Main application orchestrator)
 */

"""

    # Concatenate files
    print(f"  Concatenating {len(JS_FILES)} JavaScript files...")
    content = [banner]

    for js_file in JS_FILES:
        file_path = Path(js_file)
        if file_path.exists():
            print(f"    ‚úì {js_file}")
            content.append(f"\n/* ========================================")
            content.append(f" * Source: {js_file}")
            content.append(f" * ======================================== */\n")
            with open(file_path, 'r', encoding='utf-8') as f:
                content.append(f.read())
            content.append("\n")
        else:
            print(f"    ‚úó WARNING: {js_file} not found")

    # Combine all content
    bundle_content = '\n'.join(content)

    # Generate content hash for cache-busting
    content_hash = generate_content_hash(bundle_content)

    # Determine bundle filename
    if use_version_hash:
        bundle_filename = f"app.bundle.{__version__}.{content_hash}.js"
        min_bundle_filename = f"app.bundle.{__version__}.{content_hash}.min.js"
        sourcemap_filename = f"app.bundle.{__version__}.{content_hash}.min.js.map"
    else:
        bundle_filename = "app.bundle.js"
        min_bundle_filename = "app.bundle.min.js"
        sourcemap_filename = "app.bundle.min.js.map"

    bundle_file = dist_dir / bundle_filename
    min_bundle_file = dist_dir / min_bundle_filename

    # Write development bundle
    with open(bundle_file, 'w', encoding='utf-8') as f:
        f.write(bundle_content)

    bundle_size = len(bundle_content.encode('utf-8'))
    bundle_size_kb = bundle_size // 1024

    print(f"\n‚úÖ Bundle created: {bundle_file} ({bundle_size_kb}KB)")

    # Create manifest file for Flask template
    manifest = {
        "version": __version__,
        "build_time": datetime.utcnow().isoformat() + "Z",
        "content_hash": content_hash,
        "bundles": {
            "development": bundle_filename,
            "production": min_bundle_filename,
            "sourcemap": sourcemap_filename
        },
        "sizes": {
            "development_bytes": bundle_size,
            "development_kb": bundle_size_kb
        }
    }

    # Minify with terser if available
    terser_available = check_terser_available()

    if terser_available:
        print("\n  Minifying bundle with terser...")
        try:
            result = subprocess.run([
                "npx", "terser", str(bundle_file),
                "--compress", "drop_console=false,drop_debugger=true",
                "--mangle",
                "--comments", "false",
                "--output", str(min_bundle_file),
                "--source-map", f"filename='{sourcemap_filename}',url='{sourcemap_filename}'"
            ], capture_output=True, text=True, check=True, timeout=60)

            if min_bundle_file.exists():
                min_size = min_bundle_file.stat().st_size
                min_size_kb = min_size // 1024
                reduction = 100 - (min_size * 100 // bundle_size)
                print(f"‚úÖ Minified bundle created: {min_bundle_file} ({min_size_kb}KB, {reduction}% reduction)")

                # Update manifest with minified sizes
                manifest["sizes"]["production_bytes"] = min_size
                manifest["sizes"]["production_kb"] = min_size_kb
                manifest["sizes"]["reduction_percent"] = reduction

            if result.stderr:
                print(f"   Terser warnings: {result.stderr}")

        except subprocess.TimeoutExpired:
            print(f"‚ö†Ô∏è  Minification timed out")
        except Exception as e:
            print(f"‚ö†Ô∏è  Minification failed: {e}")
    else:
        print("\n‚ö†Ô∏è  Terser not available, skipping minification")
        print("   Install with: npm install")

    # Write manifest file
    manifest_file = dist_dir / "bundle-manifest.json"
    with open(manifest_file, 'w', encoding='utf-8') as f:
        json.dump(manifest, f, indent=2)

    print(f"\nüìÑ Bundle manifest created: {manifest_file}")

    # Clean up old bundle files (keep only latest 3 versions)
    cleanup_old_bundles(dist_dir)

    print("\nüéâ Bundle build complete!")
    print("\nüìö Bundle details:")
    print(f"   Development: {bundle_filename}")
    print(f"   Production:  {min_bundle_filename}")
    print(f"   Version:     {__version__}")
    print(f"   Hash:        {content_hash}")
    print("\nüí° The template will automatically use the manifest to load the correct bundle.")


def cleanup_old_bundles(dist_dir, keep_count=3):
    """Clean up old bundle files, keeping only the most recent versions"""
    # Find all bundle files
    dev_bundles = sorted(dist_dir.glob("app.bundle.*.js"), key=lambda p: p.stat().st_mtime, reverse=True)
    prod_bundles = sorted(dist_dir.glob("app.bundle.*.min.js"), key=lambda p: p.stat().st_mtime, reverse=True)
    sourcemaps = sorted(dist_dir.glob("app.bundle.*.min.js.map"), key=lambda p: p.stat().st_mtime, reverse=True)

    # Keep only recent versions
    files_to_remove = (
        dev_bundles[keep_count:] +
        prod_bundles[keep_count:] +
        sourcemaps[keep_count:]
    )

    if files_to_remove:
        print(f"\nüßπ Cleaning up old bundle files (keeping {keep_count} most recent)...")
        for old_file in files_to_remove:
            try:
                old_file.unlink()
                print(f"   Removed: {old_file.name}")
            except Exception as e:
                print(f"   ‚ö†Ô∏è  Could not remove {old_file.name}: {e}")


if __name__ == "__main__":
    # Parse command line arguments
    use_hash = "--no-hash" not in sys.argv
    build_bundle(use_version_hash=use_hash)
